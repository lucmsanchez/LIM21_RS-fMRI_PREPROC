#!/usr/bin/env bash

# PROCESSANDO OS ARGUMENTOS ====================================================
usage() {
    echo "Argumentos:"
    echo " $0 [ --var <txt com variáveis para análise> | --subs <ID das imagens> ]"
    echo " $0 [ -h | --help ]"
    echo
}

i=$(($# + 1)) # index of the first non-existing argument
+ i=5
declare -A longoptspec
+ declare -A longoptspec
longoptspec=( [config]=1 [subs]=1 )
+ longoptspec=([config]=1 [subs]=1)
optspec=":l:h-:"
+ optspec=:l:h-:
while getopts "$optspec" opt; do
while true; do
    case "${opt}" in
        -) #OPTARG is name-of-long-option or name-of-long-option=value
            if [[ ${OPTARG} =~ .*=.* ]] # with this --key=value format only one argument is possible
            then
                opt=${OPTARG/=*/}
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                if (($((longoptspec[$opt])) != 1))
                then
                    echo "Syntax error: Option '$opt' does not support this syntax." >&2
                    exit
                fi
                OPTARG=${OPTARG#*=}
            else #with this --key value1 value2 format multiple arguments are possible
                opt="$OPTARG"
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
                ((OPTIND+=longoptspec[$opt]))
                #echo $OPTIND
                ((OPTIND > i)) && {
                    echo "Syntax error: Not all required arguments for option '$opt' are given." >&2
                    exit
                }
            fi

            continue #now that opt/OPTARG are set we can process them as
            # if getopts would've given us long options
            ;;
        c|config)
          config=$OPTARG
            ;;
        s|subs)
            subs=$OPTARG
            ;;
        h|help)
            usage
            exit 0
            ;;
        ?)
            echo "Erro de sintaxe:'$OPTARG' desconhecida" >&2
            usage
            exit
            ;;
        *)
            echo "Erro de sintaxe:'$opt' desconhecida'" >&2
            usage
            exit
            ;;
    esac
break; done
done
+ getopts :l:h-: opt
+ true
+ case "${opt}" in
+ [[ config =~ .*=.* ]]
+ opt=config
+ (( 6 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[config] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ config=preproc.cfg
+ break
+ getopts :l:h-: opt
+ true
+ case "${opt}" in
+ [[ subs =~ .*=.* ]]
+ opt=subs
+ (( 4 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[subs] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ subs=preproc.sbj
+ break
+ getopts :l:h-: opt

# ==============================================================================

# DECLARANDO FUNÇÕES ===========================================================
check () {
  if command -v $1 > /dev/null; then
    echo "OK"
  else
    echo "Não encontrado em \$PATH"
fi
}

node () {
  [ -d $outpath ] || mkdir $outpath
  #
  local a=0; local b=0; local c=0; local d=0; local e=0
  ex=0
  #
  for i in ${in[@]}; do
      if [ ! -f $inpath$i ]; then
          echo "INPUT $i não encontrado"
          a=$((a + 1))            
      else
          for ii in ${out[@]}; do
              if [ -f $outpath$ii ]; then
                  b=$((b + 1))
                  [ $outpath$ii -ot $inpath$i ] && echo -n "INPUT $i MODIFICADO. REFAZENDO ANÁLISE. " && c=$((c + 1))
              fi
          done
      fi
  done
  #
  if [ $a -eq 0 ]; then
  #
  if [ $b -eq ${#out[@]} ]; then 
    if [ ! $c -eq 0 ]; then
      for ii in ${out[@]}; do rm $outpath$ii; done
      else
        echo "OUTPUT JÁ EXISTE. PROSSEGUINDO."; d=1
    fi
  else
      if [ ! $b -eq 0 ]; then
          echo "OUTPUT CORROMPIDO. REFAZENDO ANÁLISE."
          for ii in ${out[@]}; do rm $outpath$ii; done
      fi
  fi
  #
  while [ $d -eq 0 ]; do
  cd $inpath
    $1 &> $prefix$i.log \
      && printf "Processamento da imagem %s realizado com sucesso!\n" "$i" \
      || printf "Houve um erro no processamento da imagem %s, consulte o log %s. " "$i" "$prefix$i.log" | fold -s
    cd $pwd
    mv $inpath$prefix* $outpath
    d=1
  done
  #
  for ii in ${out[@]}; do 
    [ -f $outpath$ii ] ||  e=$((e + 1)) 
  done
  # 
  [ ! $e -eq 0 ] && echo "OUTPUT CORROMPIDO. CONSULTE O LOG."
  else
  ex=$((ex + 1)) 
  fi
}

input.error () {
[ $ex -eq ${#ID[@]} ] && exit
}

organize.files () {
  local files=$( find . -name "$i/$prefix*" )
  for i in $files; do
  mv $i $outpath
  done
}
# ==============================================================================


# INÍCIO =======================================================================

fold -s <<-EOF

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: $(date)

GNU bash           ...$(check bash)
AFNI               ...$(check afni)
FSL                ...$(check fsl5.0-fast)

EOF
+ fold -s
date
++ date
check bash
++ check bash
++ command -v bash
++ echo OK
check afni
++ check afni
++ command -v afni
++ echo OK
check fsl5.0-fast
++ check fsl5.0-fast
++ command -v fsl5.0-fast
++ echo OK

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: Tue Dec  6 10:57:55 BRST 2016

GNU bash           ...OK
AFNI               ...OK
FSL                ...OK


if ( ! command -v bash || ! command -v afni || ! command -v fsl5.0-fast) > /dev/null ; then
	printf "\nUm ou mais programas necessários para o pré-processamento não estão instalados (acima). Por favor instale o(s) programa(s) faltante(s) ou então verifique se estão configurados na variável de ambiente \$PATH\n\n" | fold -s
	exit
fi
+ command -v bash
+ command -v afni
+ command -v fsl5.0-fast

if [ ! -z $config ]; then  
  if [ -f $config ]; then
    source $config
    a=0
    for var in ptn mcbase gRL gAP gIS orient template blur; do
      if [[ -z "${!var:-}" ]]; then
      echo "Variável $var não encontrada"
      a=$(($a + 1))
      fi
    done
    if [ ! $a -eq 0 ]; then
      echo "Erro: Não é possível executar o script sem as variáveis acima estarem definidas no arquivo de configuração. Encerrando"
      exit
    fi
    unset a
  else
  echo "Arquivo de configuração especificado não encontrado"
  exit
  fi
else 
  echo "O arquivo de configuração não foi especificado"
  if [ ! -f preproc.cfg ]; then
    echo "Será criado um arquivo de configuração com valores padrão: preproc.cfg"
    cat > preproc.cfg << EOL
# Variáveis RS-fMRI Preprocessing:

ptn=seq+z
mcbase=100
gRL=90
gAP=90
gIS=60
orient="rpi"
template="MNI152_1mm_uni+tlrc"
blur=6
EOL
exit
  else
    echo "Será usado o arquivo local preproc.cfg"
    source preproc.cfg
  fi
fi  
+ '[' '!' -z preproc.cfg ']'
+ '[' -f preproc.cfg ']'
+ source preproc.cfg
# Variáveis RS-fMRI Preprocessing:

ptn=seq+z
++ ptn=seq+z
mcbase=100
++ mcbase=100
gRL=90
++ gRL=90
gAP=90
++ gAP=90
gIS=60
++ gIS=60
orient="rpi"
++ orient=rpi
template="MNI152_1mm_uni+tlrc"
++ template=MNI152_1mm_uni+tlrc
blur=6
++ blur=6
+ a=0
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z seq+z ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 100 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 90 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 90 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 60 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z rpi ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z MNI152_1mm_uni+tlrc ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 6 ]]
+ '[' '!' 0 -eq 0 ']'
+ unset a


# informando os usuários das variáveis definidas ou defaults
fold -s <<-EOF
As variáveis que serão usadas como parametros para as análises são:
Slice timing correction - sequência de aquisição => $ptn
Motion correction       - valor base             => $mcbase
Homogenize Grid         - tamanho da grade       => $gRL $gAP $gIS

EOF
+ fold -s
As variáveis que serão usadas como parametros para as análises são:
Slice timing correction - sequência de aquisição => seq+z
Motion correction       - valor base             => 100
Homogenize Grid         - tamanho da grade       => 90 90 60


# Checando arquivo com nome dos indivíduos
if [ ! -z $subs ]; then  
  if [ ! -f $subs ]; then
    echo "Arquivo com ID dos indivíduos especificado não encontrado"
    exit
  fi
else 
  if [ -f preproc.sbj ]; then
    subs=preproc.sbj
  else
    echo "O arquivo com ID dos indivíduos não foi especificado" 
    exit
  fi
fi  
+ '[' '!' -z preproc.sbj ']'
+ '[' '!' -f preproc.sbj ']'

ID=$(cat $subs)
cat $subs
++ cat preproc.sbj
+ ID='C000917
P001543
P001562
T000001'
echo "Lista de indivíduos para análise:"
+ echo 'Lista de indivíduos para análise:'
Lista de indivíduos para análise:
a=0
+ a=0
for i in $ID; do 
  echo -n "$i  ... " 
  if [ $(find . -name "T1_$i.nii") ] && [ $(find . -name "T1_$i.PAR") ]; then
    echo -n "T1" 
  else echo -n "(T1 não encontrado)"; a=$((a + 1))
  fi
  if [ $(find . -name "RS_$i.nii") ] && [ $(find . -name "RS_$i.PAR") ]; then
    echo " RS" 
  else echo " (RS não encontrado)"; a=$((a + 1)) 
  fi
  [ $(find . -name "t_RS_$i.nii") ] && echo " stc"
done
+ for i in '$ID'
+ echo -n 'C000917  ... '
C000917  ... find . -name "T1_$i.nii"
++ find . -name T1_C000917.nii
+ '[' ./DATA/C000917/T1_C000917.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_C000917.PAR
+ '[' ./DATA/C000917/T1_C000917.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_C000917.nii
+ '[' ./DATA/C000917/RS_C000917.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_C000917.PAR
+ '[' ./DATA/C000917/RS_C000917.PAR ']'
+ echo ' RS'
 RS
find . -name "t_RS_$i.nii"
++ find . -name t_RS_C000917.nii
+ '[' ']'
+ for i in '$ID'
+ echo -n 'P001543  ... '
P001543  ... find . -name "T1_$i.nii"
++ find . -name T1_P001543.nii
+ '[' ./DATA/P001543/T1_P001543.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001543.PAR
+ '[' ./DATA/P001543/T1_P001543.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001543.nii
+ '[' ./DATA/P001543/RS_P001543.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001543.PAR
+ '[' ./DATA/P001543/RS_P001543.PAR ']'
+ echo ' RS'
 RS
find . -name "t_RS_$i.nii"
++ find . -name t_RS_P001543.nii
+ '[' ']'
+ for i in '$ID'
+ echo -n 'P001562  ... '
P001562  ... find . -name "T1_$i.nii"
++ find . -name T1_P001562.nii
+ '[' ./DATA/P001562/T1_P001562.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001562.PAR
+ '[' ./DATA/P001562/T1_P001562.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001562.nii
+ '[' ./DATA/P001562/RS_P001562.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001562.PAR
+ '[' ./DATA/P001562/RS_P001562.PAR ']'
+ echo ' RS'
 RS
find . -name "t_RS_$i.nii"
++ find . -name t_RS_P001562.nii
+ '[' ']'
+ for i in '$ID'
+ echo -n 'T000001  ... '
T000001  ... find . -name "T1_$i.nii"
++ find . -name T1_T000001.nii
+ '[' ./DATA/T000001/T1_T000001.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_T000001.PAR
+ '[' ./DATA/T000001/T1_T000001.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_T000001.nii
+ '[' ./DATA/T000001/RS_T000001.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_T000001.PAR
+ '[' ./DATA/T000001/RS_T000001.PAR ']'
+ echo ' RS'
 RS
find . -name "t_RS_$i.nii"
++ find . -name t_RS_T000001.nii
+ '[' ']'
echo
+ echo

if [ ! $a -eq 0 ]; then
    echo "Imagens não foram encontradas ou não estão nomeadas conforme o padrão: RS_<ID>.nii/RS_<ID>.PAR e T1_<ID>.nii/T1_<ID>" | fold -s ; echo
    exit
fi
+ '[' '!' 0 -eq 0 ']'

[ -d DATA ] || mkdir DATA
+ '[' -d DATA ']'
[ -d OUTPUT ] || mkdir OUTPUT
+ '[' -d OUTPUT ']'

unset a; a=0
+ unset a
+ a=0
for i in $ID; do
  [ -d DATA/$i ] || mkdir DATA/$i 
  [ -d OUTPUT/$i ] || mkdir OUTPUT/$i 
  for ii in T1_$i.nii T1_$i.PAR RS_$i.nii RS_$i.PAR physlog_$i; do
    [ ! -f DATA/$i/$ii ] && wp=$(find . -name $ii) && rp=DATA/$i/$ii && mv $wp $rp 2> /dev/null && a=$((a + 1))
  done
done
+ for i in '$ID'
+ '[' -d DATA/C000917 ']'
+ '[' -d OUTPUT/C000917 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/physlog_C000917 ']'
find . -name $ii
++ find . -name physlog_C000917
+ wp=
+ rp=DATA/C000917/physlog_C000917
+ mv DATA/C000917/physlog_C000917
+ for i in '$ID'
+ '[' -d DATA/P001543 ']'
+ '[' -d OUTPUT/P001543 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/physlog_P001543 ']'
find . -name $ii
++ find . -name physlog_P001543
+ wp=
+ rp=DATA/P001543/physlog_P001543
+ mv DATA/P001543/physlog_P001543
+ for i in '$ID'
+ '[' -d DATA/P001562 ']'
+ '[' -d OUTPUT/P001562 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/physlog_P001562 ']'
find . -name $ii
++ find . -name physlog_P001562
+ wp=
+ rp=DATA/P001562/physlog_P001562
+ mv DATA/P001562/physlog_P001562
+ for i in '$ID'
+ '[' -d DATA/T000001 ']'
+ '[' -d OUTPUT/T000001 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/physlog_T000001 ']'
find . -name $ii
++ find . -name physlog_T000001
+ wp=
+ rp=DATA/T000001/physlog_T000001
+ mv DATA/T000001/physlog_T000001
if [ ! $a -eq 0 ]; then 
  echo "O caminho das imagens não está conformado com o padrâo: DATA/<ID>/T1_<ID>.nii"
  echo "Conformando..."
  echo
fi
+ '[' '!' 0 -eq 0 ']'

# SLICE TIMING CORRECTION=======================================================
printf "=======================SLICE TIMING CORRECTION====================\n\n"
+ printf '=======================SLICE TIMING CORRECTION====================\n\n'
=======================SLICE TIMING CORRECTION====================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  prefix=t_RS_
  in=RS_$i.nii
  out=$prefix$i.nii
  inpath=DATA/$i/
  outpath=DATA/$i/slice_correction/
  echo -n "$i> "
  node "3dTshift \
    -verbose \
    -tpattern $ptn \
    -prefix $out \
    -Fourier \
    $in"
input.error
organize.files
unset prefix in out inpath outpath 
done
+ for i in '$ID'
+ prefix=t_RS_
+ in=RS_C000917.nii
+ out=t_RS_C000917.nii
+ inpath=DATA/C000917/
+ outpath=DATA/C000917/slice_correction/
+ echo -n 'C000917> '
C000917> + node '3dTshift     -verbose     -tpattern seq+z     -prefix t_RS_C000917.nii     -Fourier     RS_C000917.nii'
+ '[' -d DATA/C000917/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local e=0
+ ex=0
+ for i in '${in[@]}'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for ii in '${out[@]}'
+ '[' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 1 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ cd DATA/C000917/
+ 3dTshift -verbose -tpattern seq+z -prefix t_RS_C000917.nii -Fourier RS_C000917.nii
+ fold -s
+ printf 'Houve um erro no processamento da imagem %s, consulte o log %s. ' RS_C000917.nii t_RS_RS_C000917.nii.log
Houve um erro no processamento da imagem RS_C000917.nii, consulte o log 
t_RS_RS_C000917.nii.log. + cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/C000917/t_RS_RS_C000917.nii.log DATA/C000917/slice_correction/
+ d=1
+ '[' 1 -eq 0 ']'
+ for ii in '${out[@]}'
+ '[' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. CONSULTE O LOG.'
OUTPUT CORROMPIDO. CONSULTE O LOG.
+ input.error
+ '[' 0 -eq 1 ']'
+ organize.files
 find . -name "$i/$prefix*" 
++ find . -name 'RS_C000917.nii/t_RS_*'
find: warning: Unix filenames usually don't contain slashes (though pathnames do).  That means that '-name `RS_C000917.nii/t_RS_*'' will probably evaluate to false all the time on this system.  You might find the '-wholename' test more useful, or perhaps '-samefile'.  Alternatively, if you are using GNU grep, you could use 'find ... -print0 | grep -FzZ `RS_C000917.nii/t_RS_*''.
+ local files=
+ unset prefix in out inpath outpath
+ for i in '$ID'
+ prefix=t_RS_
+ in=RS_P001543.nii
+ out=t_RS_P001543.nii
+ inpath=DATA/P001543/
+ outpath=DATA/P001543/slice_correction/
+ echo -n 'P001543> '
P001543> + node '3dTshift     -verbose     -tpattern seq+z     -prefix t_RS_P001543.nii     -Fourier     RS_P001543.nii'
+ '[' -d DATA/P001543/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local e=0
+ ex=0
+ for i in '${in[@]}'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for ii in '${out[@]}'
+ '[' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 1 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ cd DATA/P001543/
+ 3dTshift -verbose -tpattern seq+z -prefix t_RS_P001543.nii -Fourier RS_P001543.nii
+ fold -s
+ printf 'Houve um erro no processamento da imagem %s, consulte o log %s. ' RS_P001543.nii t_RS_RS_P001543.nii.log
Houve um erro no processamento da imagem RS_P001543.nii, consulte o log 
t_RS_RS_P001543.nii.log. + cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/P001543/t_RS_RS_P001543.nii.log DATA/P001543/slice_correction/
+ d=1
+ '[' 1 -eq 0 ']'
+ for ii in '${out[@]}'
+ '[' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. CONSULTE O LOG.'
OUTPUT CORROMPIDO. CONSULTE O LOG.
+ input.error
+ '[' 0 -eq 1 ']'
+ organize.files
 find . -name "$i/$prefix*" 
++ find . -name 'RS_P001543.nii/t_RS_*'
find: warning: Unix filenames usually don't contain slashes (though pathnames do).  That means that '-name `RS_P001543.nii/t_RS_*'' will probably evaluate to false all the time on this system.  You might find the '-wholename' test more useful, or perhaps '-samefile'.  Alternatively, if you are using GNU grep, you could use 'find ... -print0 | grep -FzZ `RS_P001543.nii/t_RS_*''.
+ local files=
+ unset prefix in out inpath outpath
+ for i in '$ID'
+ prefix=t_RS_
+ in=RS_P001562.nii
+ out=t_RS_P001562.nii
+ inpath=DATA/P001562/
+ outpath=DATA/P001562/slice_correction/
+ echo -n 'P001562> '
P001562> + node '3dTshift     -verbose     -tpattern seq+z     -prefix t_RS_P001562.nii     -Fourier     RS_P001562.nii'
+ '[' -d DATA/P001562/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local e=0
+ ex=0
+ for i in '${in[@]}'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for ii in '${out[@]}'
+ '[' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 1 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ cd DATA/P001562/
+ 3dTshift -verbose -tpattern seq+z -prefix t_RS_P001562.nii -Fourier RS_P001562.nii
+ fold -s
+ printf 'Houve um erro no processamento da imagem %s, consulte o log %s. ' RS_P001562.nii t_RS_RS_P001562.nii.log
Houve um erro no processamento da imagem RS_P001562.nii, consulte o log 
t_RS_RS_P001562.nii.log. + cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/P001562/t_RS_RS_P001562.nii.log DATA/P001562/slice_correction/
+ d=1
+ '[' 1 -eq 0 ']'
+ for ii in '${out[@]}'
+ '[' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. CONSULTE O LOG.'
OUTPUT CORROMPIDO. CONSULTE O LOG.
+ input.error
+ '[' 0 -eq 1 ']'
+ organize.files
 find . -name "$i/$prefix*" 
++ find . -name 'RS_P001562.nii/t_RS_*'
find: warning: Unix filenames usually don't contain slashes (though pathnames do).  That means that '-name `RS_P001562.nii/t_RS_*'' will probably evaluate to false all the time on this system.  You might find the '-wholename' test more useful, or perhaps '-samefile'.  Alternatively, if you are using GNU grep, you could use 'find ... -print0 | grep -FzZ `RS_P001562.nii/t_RS_*''.
+ local files=
+ unset prefix in out inpath outpath
+ for i in '$ID'
+ prefix=t_RS_
+ in=RS_T000001.nii
+ out=t_RS_T000001.nii
+ inpath=DATA/T000001/
+ outpath=DATA/T000001/slice_correction/
+ echo -n 'T000001> '
T000001> + node '3dTshift     -verbose     -tpattern seq+z     -prefix t_RS_T000001.nii     -Fourier     RS_T000001.nii'
+ '[' -d DATA/T000001/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local e=0
+ ex=0
+ for i in '${in[@]}'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for ii in '${out[@]}'
+ '[' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 1 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ cd DATA/T000001/
+ 3dTshift -verbose -tpattern seq+z -prefix t_RS_T000001.nii -Fourier RS_T000001.nii
+ fold -s
+ printf 'Houve um erro no processamento da imagem %s, consulte o log %s. ' RS_T000001.nii t_RS_RS_T000001.nii.log
Houve um erro no processamento da imagem RS_T000001.nii, consulte o log 
t_RS_RS_T000001.nii.log. + cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/T000001/t_RS_RS_T000001.nii.log DATA/T000001/slice_correction/
+ d=1
+ '[' 1 -eq 0 ']'
+ for ii in '${out[@]}'
+ '[' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. CONSULTE O LOG.'
OUTPUT CORROMPIDO. CONSULTE O LOG.
+ input.error
+ '[' 0 -eq 1 ']'
+ organize.files
 find . -name "$i/$prefix*" 
++ find . -name 'RS_T000001.nii/t_RS_*'
find: warning: Unix filenames usually don't contain slashes (though pathnames do).  That means that '-name `RS_T000001.nii/t_RS_*'' will probably evaluate to false all the time on this system.  You might find the '-wholename' test more useful, or perhaps '-samefile'.  Alternatively, if you are using GNU grep, you could use 'find ... -print0 | grep -FzZ `RS_T000001.nii/t_RS_*''.
+ local files=
+ unset prefix in out inpath outpath
echo
+ echo


exit
+ exit
