#!/usr/bin/env bash


qc () {
  while [[ $# -gt 0 ]]
  do
  k="$1"
  case $k in
    -e)
    e="$2"
    shift
    ;;
    -i)
    f1="$2"
    shift
    ;;
    -o)
    f2="$2"
    shift # past argument
    ;;
    *)
     echo "Erro de sintaxe" >&2
     usage
     exit       # unknown option
    ;;
  esac
  shift # past argument or value
  done

  local a=0; local b=0; local c=0; local d=0
  go=1

  cd ${steppath[$j]}
  echo -n "${ID[j]}> "
  for ii in $f1; do
    for file in ${ii}*; do
      [ ! -f $file ] && echo "INPUT $ii não encontrado" && a=$((a + 1))
      for iii in $f2; do
        for file2 in ${iii}*; do
          [ ! -f $file2 ] && b=$((b + 1)) || c=$((c + 1))
          [ $file2 -ot $file ] && d=$((d + 1))
        done
      done
    done
  done
  #echo $a $b $c $d
  if [ $a -eq 0 ]; then
    if [ $b -eq 0 ]; then 
      if [ ! $d -eq 0 ]; then
        printf "INPUT $ii MODIFICADO. REFAZENDO ANÁLISE. " 
        for iii in $f2; do 
          rm ${iii}* 2> /dev/null; 
        done
        go=1
      else
        echo "OUTPUT JÁ EXISTE. PROSSEGUINDO."; go=0; ex=0
      fi
    else
      if [ ! $c -eq 0 ]; then
        echo "OUTPUT CORROMPIDO. REFAZENDO ANÁLISE."
        for iii in $f2; do 
        rm ${iii}* 2> /dev/null; done
        go=1
      else
        go=1
      fi
    fi
  else
    go=0; ex=$((ex + 1))
  fi  

  if [ $go -eq 1 ]; then
    ( echo 
    echo "================================================================================"
    echo "ETAPA: $e  - RUNTIME: $(date)" 
    echo "================================================================================"
    echo 
    echo "INPUTS: $f1" 
    echo "OUTPUTS: $f2"
    echo ) >> preproc.${ID[j]}.log
    return 0
  else
    return 1
  fi
}

qc.close () {
  local a=0
  if [ $go -eq 1 ]; then  
    for iii in $f2; do
      for file2 in ${iii}*; do
        [ -f $file2 ] ||  a=$((a + 1)) 
      done
    done
    if [ ! $a -eq 0 ]; then
      printf "Houve um erro no processamento da imagem %s, consulte o log. \n" "${ID[j]}" && ex=$((ex + 1))
    else
      printf "Processamento da imagem %s realizado com sucesso! \n" "${ID[j]}"
    fi
  fi
  cd $pwd
  unset e f1 f2
}

qc.open -e "QC 1"                                    \
        -i "teste1 teste2 teste3 teste4 teste5"      \
        -o "teste6 teste7 teste8 teste9"             \
if $?; then
XXXXX
fi
qc.close

#==========================================================================
#==========================================================================
#==========================================================================
#==========================================================================


node.open () {
  while [[ $# -gt 0 ]]
  do
  k='$1'
  case $k in
    -e)
    e='$2'
    shift
    ;;
    -l)
    declare -a l=("${!2}")
    shift
    ;;
    -i)
    f1='$2'
    shift
    ;;
    -o)
    f2='$2'
    shift # past argument
    ;;
    *)
     echo "Erro de sintaxe" >&2
     usage
     exit       # unknown option
    ;;
  esac
  shift # past argument or value
  done

  printf "=============================${e}==================================\n\n"

  local a=0; local b=0; local c=0; local d=0
  go=1

  cd ${steppath[$j]}
  echo -n "${ID[j]}> "
  for ii in $f1; do
    for file in ${ii}*; do
      [ ! -f $file ] && echo "INPUT $ii não encontrado" && a=$((a + 1))
      for iii in $f2; do
        for file2 in ${iii}*; do
          [ ! -f $file2 ] && b=$((b + 1)) || c=$((c + 1))
          [ $file2 -ot $file ] && d=$((d + 1))
        done
      done
    done
  done
  #echo $a $b $c $d
  if [ $a -eq 0 ]; then
    if [ $b -eq 0 ]; then 
      if [ ! $d -eq 0 ]; then
        printf "INPUT $ii MODIFICADO. REFAZENDO ANÁLISE. " 
        for iii in $f2; do 
          rm ${iii}* 2> /dev/null; 
        done
        go=1
      else
        echo "OUTPUT JÁ EXISTE. PROSSEGUINDO."; go=0; ex=0
      fi
    else
      if [ ! $c -eq 0 ]; then
        echo "OUTPUT CORROMPIDO. REFAZENDO ANÁLISE."
        for iii in $f2; do 
        rm ${iii}* 2> /dev/null; done
        go=1
      else
        go=1
      fi
    fi
  else
    go=0; ex=$((ex + 1))
  fi  

  if [ $go -eq 1 ]; then
    ( echo 
    echo "================================================================================"
    echo "ETAPA: $e  - RUNTIME: $(date)" 
    echo "================================================================================"
    echo 
    echo "INPUTS: $f1" 
    echo "OUTPUTS: $f2"
    echo ) >> preproc.${ID[j]}.log
    return 0
  else
    return 1
  fi
}

close.node () {
  local a=0
  if [ $go -eq 1 ]; then  
    for iii in $f2; do
      for file2 in ${iii}*; do
        [ -f $file2 ] ||  a=$((a + 1)) 
      done
    done
    if [ ! $a -eq 0 ]; then
      printf "Houve um erro no processamento da imagem %s, consulte o log. \n" "${ID[j]}" && ex=$((ex + 1))
    else
      printf "Processamento da imagem %s realizado com sucesso! \n" "${ID[j]}"
    fi
  fi
  cd $pwd
}

printf "=============================TESTE==================================\n\n"
for j in ${!ID[@]}; do
node.open -e "TESTE"                                   \
          -i "${out[$j]}"                              \
          -o "tshift.RS.${ID[j]}+orig"                 \
if $?; then
3dTshift \
      -tpattern $ptn \
      -prefix ${out[$j]} \
      -Fourier \
      ${in[$j]} &>> preproc.${ID[j]}.log
fi
node.close
done
input.error

