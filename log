#!/usr/bin/env bash

# PROCESSANDO OS ARGUMENTOS ====================================================
usage() {
    echo "Argumentos:"
    echo " $0 [ --var <txt com variáveis para análise> | --subs <ID das imagens> ]"
    echo " $0 [ -h | --help ]"
    echo
}

aztec=0
+ aztec=0


i=$(($# + 1)) # index of the first non-existing argument
+ i=5
declare -A longoptspec
+ declare -A longoptspec
longoptspec=( [config]=1 [subs]=1 )
+ longoptspec=([config]=1 [subs]=1)
optspec=":l:h:a-:"
+ optspec=:l:h:a-:
while getopts "$optspec" opt; do
while true; do
    case "${opt}" in
        -) #OPTARG is name-of-long-option or name-of-long-option=value
            if [[ ${OPTARG} =~ .*=.* ]] # with this --key=value format only one argument is possible
            then
                opt=${OPTARG/=*/}
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                if (($((longoptspec[$opt])) != 1))
                then
                    echo "Syntax error: Option '$opt' does not support this syntax." >&2
                    exit
                fi
                OPTARG=${OPTARG#*=}
            else #with this --key value1 value2 format multiple arguments are possible
                opt="$OPTARG"
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
                ((OPTIND+=longoptspec[$opt]))
                #echo $OPTIND
                ((OPTIND > i)) && {
                    echo "Syntax error: Not all required arguments for option '$opt' are given." >&2
                    exit
                }
            fi

            continue #now that opt/OPTARG are set we can process them as
            # if getopts would've given us long options
            ;;
       a|aztec)
            aztec=1
            ;;
        c|config)
          config=$OPTARG
            ;;
        s|subs)
            subs=$OPTARG
            ;;
        h|help)
            usage
            exit 0
            ;;
        ?)
            echo "Erro de sintaxe:'$OPTARG' desconhecida" >&2
            usage
            exit
            ;;
        *)
            echo "Erro de sintaxe:'$opt' desconhecida'" >&2
            usage
            exit
            ;;
    esac
break; done
done
+ getopts :l:h:a-: opt
+ true
+ case "${opt}" in
+ [[ config =~ .*=.* ]]
+ opt=config
+ (( 6 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[config] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ config=preproc.cfg
+ break
+ getopts :l:h:a-: opt
+ true
+ case "${opt}" in
+ [[ subs =~ .*=.* ]]
+ opt=subs
+ (( 4 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[subs] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ subs=preproc.sbj
+ break
+ getopts :l:h:a-: opt

# ==============================================================================

# DECLARANDO FUNÇÕES ===========================================================
check () {
  if command -v $1 > /dev/null; then
    echo "OK"
  else
    echo "Não encontrado em \$PATH"
fi
}

input.error () {
[ $ex -eq ${#ID[@]} ] && exit
}

open.node () {
  
  echo ${in[$i]}
  echo ${inpath[$i]}
  echo ${out[$i]}
  echo ${outpath[$i]}

  [ -d ${outpath[$i]} ] || mkdir ${outpath[$i]}
  #
  local a=0; local b=0; local c=0; local d=0; local e=0; local v=0
  ex=0; go=1
  #
  for ii in ${in[$i]} ${in_2[$i]} ${in_3[$i]} ${in_4[$i]}; do
      if [ ! -f ${inpath[$i]}$ii ]; then
          echo "INPUT $ii não encontrado"
          a=$((a + 1))            
      else
          for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do
              if [ ! -f ${outpath[$i]}$iii ]; then
                  b=$((b + 1))
                else
                  d=$((d + 1))
                  [ ${outpath[$i]}$iii -ot ${inpath[$i]}$ii ] && echo -n "INPUT $ii MODIFICADO. REFAZENDO ANÁLISE. " && c=$((c + 1))
              fi
          done
      fi
  done
  #
  if [ $a -eq 0 ]; then
  #
    if [ $b -eq 0 ]; then 
      if [ ! $c -eq 0 ]; then
        for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do rm ${outpath[$i]}$iii; done
      else
          echo "OUTPUT JÁ EXISTE. PROSSEGUINDO."; go=0
      fi
    else
        if [ ! $d -eq 0 ]; then
            echo "OUTPUT CORROMPIDO. REFAZENDO ANÁLISE."
            for ii in ${out[@]}; do rm ${outpath[$i}$ii; done
        fi
    fi
    #
    if [ $go -eq 1 ]; then
      cd ${inpath[$i]}
    fi
  else
  go=0
  fi
  
}

close.node () {
  if [ $go -eq 1 ]; then  
    cd $pwd
    mv ${inpath[$i]}$prefix* ${outpath[$i]}
     for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do 
      [ -f ${outpath[$i]}$iii ] ||  e=$((e + 1)) 
    done
    # 
    [ ! $e -eq 0 ] && echo "OUTPUT CORROMPIDO. CONSULTE O LOG."
  else
    ex=$((ex + 1)) 
  fi

 local files=$( find "${inpath[$i]}" -name "$prefix*" )
  for f in $files; do
    mv $f ${outpath[$i]} 2> /dev/null
  done
}

# ==============================================================================


# INÍCIO =======================================================================

fold -s <<-EOF

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: $(date)

Programas necessários:
GNU bash           ...$(check bash)
AFNI               ...$(check afni)
FSL                ...$(check fsl5.0-fast)
MATLAB             ...$(check matlab)
  SPM5
  aztec

EOF
+ fold -s
date
++ date
check bash
++ check bash
++ command -v bash
++ echo OK
check afni
++ check afni
++ command -v afni
++ echo OK
check fsl5.0-fast
++ check fsl5.0-fast
++ command -v fsl5.0-fast
++ echo OK
check matlab
++ check matlab
++ command -v matlab
++ echo OK

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: Thu Dec  8 14:47:56 BRST 2016

Programas necessários:
GNU bash           ...OK
AFNI               ...OK
FSL                ...OK
MATLAB             ...OK
  SPM5
  aztec


if ( ! command -v bash || ! command -v afni || ! command -v fsl5.0-fast  ) > /dev/null ; then
	printf "\nUm ou mais programas necessários para o pré-processamento não estão instalados (acima). Por favor instale o(s) programa(s) faltante(s) ou então verifique se estão configurados na variável de ambiente \$PATH\n\n" | fold -s
	exit
fi
+ command -v bash
+ command -v afni
+ command -v fsl5.0-fast
[ $aztec -eq 1 ] && [ ! $(command -v matlab) ] && echo "o Matlab e os plugins SPM5 e aztec são necessários para a análise e não foram encontrados. Certifique-se que eles estão instalados e configurados na variável de ambiente $PATH" | fold -s && exit 
+ '[' 0 -eq 1 ']'

if [ ! -z $config ]; then  
  if [ -f $config ]; then
    source $config
    a=0
    for var in ptn mcbase gRL gAP gIS orient template blur; do
      if [[ -z "${!var:-}" ]]; then
      echo "Variável $var não encontrada"
      a=$(($a + 1))
      fi
    done
    if [ ! $a -eq 0 ]; then
      echo "Erro: Não é possível executar o script sem as variáveis acima estarem definidas no arquivo de configuração. Encerrando"
      exit
    fi
    unset a
  else
  echo "Arquivo de configuração especificado não encontrado"
  exit
  fi
else 
  echo "O arquivo de configuração não foi especificado"
  if [ ! -f preproc.cfg ]; then
    echo "Será criado um arquivo de configuração com valores padrão: preproc.cfg"
    cat > preproc.cfg << EOL
# Variáveis RS-fMRI Preprocessing:

TR=2000
hp=0
ptn=seq+z
mcbase=100
gRL=90
gAP=90
gIS=60
orient="rpi"
template="MNI152_1mm_uni+tlrc"
blur=6
EOL
exit
  else
    echo "Será usado o arquivo local preproc.cfg"
    source preproc.cfg
  fi
fi  
+ '[' '!' -z preproc.cfg ']'
+ '[' -f preproc.cfg ']'
+ source preproc.cfg
# Variáveis RS-fMRI Preprocessing:

TR=2000
++ TR=2000
hp=0
++ hp=0
ptn=seq+z
++ ptn=seq+z
mcbase=100
++ mcbase=100
gRL=90
++ gRL=90
gAP=90
++ gAP=90
gIS=60
++ gIS=60
orient="rpi"
++ orient=rpi
template="MNI152_1mm_uni+tlrc"
++ template=MNI152_1mm_uni+tlrc
blur=6
++ blur=6
+ a=0
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z seq+z ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 100 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 90 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 90 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 60 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z rpi ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z MNI152_1mm_uni+tlrc ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 6 ]]
+ '[' '!' 0 -eq 0 ']'
+ unset a


# informando os usuários das variáveis definidas ou defaults
fold -s <<-EOF
As variáveis que serão usadas como parametros para as análises são:
Aztec                   - Tempo de repetição(ms)  => $TR
Slice timing correction - sequência de aquisição  => $ptn
Motion correction       - valor base              => $mcbase
Homogenize Grid         - tamanho da grade        => $gRL $gAP $gIS

EOF
+ fold -s
As variáveis que serão usadas como parametros para as análises são:
Aztec                   - Tempo de repetição(ms)  => 2000
Slice timing correction - sequência de aquisição  => seq+z
Motion correction       - valor base              => 100
Homogenize Grid         - tamanho da grade        => 90 90 60


# Checando arquivo com nome dos indivíduos
if [ ! -z $subs ]; then  
  if [ ! -f $subs ]; then
    echo "Arquivo com ID dos indivíduos especificado não encontrado"
    exit
  fi
else 
  if [ -f preproc.sbj ]; then
    subs=preproc.sbj
  else
    echo "O arquivo com ID dos indivíduos não foi especificado" 
    exit
  fi
fi  
+ '[' '!' -z preproc.sbj ']'
+ '[' '!' -f preproc.sbj ']'

ID=$(cat $subs)
cat $subs
++ cat preproc.sbj
+ ID='C000917
P001543
P001562
T000001'
echo "Lista de indivíduos para análise:"
+ echo 'Lista de indivíduos para análise:'
Lista de indivíduos para análise:
a=0
+ a=0
for i in $ID; do 
  echo -n "$i  ... " 
  if [ $(find . -name "T1_$i.nii") ] && [ $(find . -name "T1_$i.PAR") ]; then
    echo -n "T1" 
  else echo -n "(T1 não encontrado)"; a=$((a + 1))
  fi
  if [ $(find . -name "RS_$i.nii") ] && [ $(find . -name "RS_$i.PAR") ]; then
    printf " RS" 
  else echo " (RS não encontrado)"; a=$((a + 1)) 
  fi
  [ $(find . -name "*t*$i.nii") ] && printf " stc"
  printf "\n"
done
+ for i in '$ID'
+ echo -n 'C000917  ... '
C000917  ... find . -name "T1_$i.nii"
++ find . -name T1_C000917.nii
+ '[' ./DATA/C000917/T1_C000917.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_C000917.PAR
+ '[' ./DATA/C000917/T1_C000917.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_C000917.nii
+ '[' ./DATA/C000917/RS_C000917.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_C000917.PAR
+ '[' ./DATA/C000917/RS_C000917.PAR ']'
+ printf ' RS'
 RSfind . -name "*t*$i.nii"
++ find . -name '*t*C000917.nii'
+ '[' ']'
+ printf '\n'

+ for i in '$ID'
+ echo -n 'P001543  ... '
P001543  ... find . -name "T1_$i.nii"
++ find . -name T1_P001543.nii
+ '[' ./DATA/P001543/T1_P001543.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001543.PAR
+ '[' ./DATA/P001543/T1_P001543.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001543.nii
+ '[' ./DATA/P001543/RS_P001543.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001543.PAR
+ '[' ./DATA/P001543/RS_P001543.PAR ']'
+ printf ' RS'
 RSfind . -name "*t*$i.nii"
++ find . -name '*t*P001543.nii'
+ '[' ']'
+ printf '\n'

+ for i in '$ID'
+ echo -n 'P001562  ... '
P001562  ... find . -name "T1_$i.nii"
++ find . -name T1_P001562.nii
+ '[' ./DATA/P001562/T1_P001562.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001562.PAR
+ '[' ./DATA/P001562/T1_P001562.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001562.nii
+ '[' ./DATA/P001562/RS_P001562.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001562.PAR
+ '[' ./DATA/P001562/RS_P001562.PAR ']'
+ printf ' RS'
 RSfind . -name "*t*$i.nii"
++ find . -name '*t*P001562.nii'
+ '[' ']'
+ printf '\n'

+ for i in '$ID'
+ echo -n 'T000001  ... '
T000001  ... find . -name "T1_$i.nii"
++ find . -name T1_T000001.nii
+ '[' ./DATA/T000001/T1_T000001.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_T000001.PAR
+ '[' ./DATA/T000001/T1_T000001.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_T000001.nii
+ '[' ./DATA/T000001/RS_T000001.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_T000001.PAR
+ '[' ./DATA/T000001/RS_T000001.PAR ']'
+ printf ' RS'
 RSfind . -name "*t*$i.nii"
++ find . -name '*t*T000001.nii'
+ '[' ']'
+ printf '\n'

echo
+ echo

if [ ! $a -eq 0 ]; then
    echo "Imagens não foram encontradas ou não estão nomeadas conforme o padrão: RS_<ID>.nii/RS_<ID>.PAR e T1_<ID>.nii/T1_<ID>" | fold -s ; echo
    exit
fi
+ '[' '!' 0 -eq 0 ']'

[ -d DATA ] || mkdir DATA
+ '[' -d DATA ']'
[ -d OUTPUT ] || mkdir OUTPUT
+ '[' -d OUTPUT ']'

unset a; a=0
+ unset a
+ a=0
for i in $ID; do
  [ -d DATA/$i ] || mkdir DATA/$i 
  [ -d OUTPUT/$i ] || mkdir OUTPUT/$i 
  for ii in T1_$i.nii T1_$i.PAR RS_$i.nii RS_$i.PAR physlog_$i; do
    [ ! -f DATA/$i/$ii ] && wp=$(find . -name $ii) && rp=DATA/$i/$ii && mv $wp $rp 2> /dev/null && a=$((a + 1))
  done
done
+ for i in '$ID'
+ '[' -d DATA/C000917 ']'
+ '[' -d OUTPUT/C000917 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/physlog_C000917 ']'
find . -name $ii
++ find . -name physlog_C000917
+ wp=
+ rp=DATA/C000917/physlog_C000917
+ mv DATA/C000917/physlog_C000917
+ for i in '$ID'
+ '[' -d DATA/P001543 ']'
+ '[' -d OUTPUT/P001543 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/physlog_P001543 ']'
find . -name $ii
++ find . -name physlog_P001543
+ wp=
+ rp=DATA/P001543/physlog_P001543
+ mv DATA/P001543/physlog_P001543
+ for i in '$ID'
+ '[' -d DATA/P001562 ']'
+ '[' -d OUTPUT/P001562 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/physlog_P001562 ']'
find . -name $ii
++ find . -name physlog_P001562
+ wp=
+ rp=DATA/P001562/physlog_P001562
+ mv DATA/P001562/physlog_P001562
+ for i in '$ID'
+ '[' -d DATA/T000001 ']'
+ '[' -d OUTPUT/T000001 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/physlog_T000001 ']'
find . -name $ii
++ find . -name physlog_T000001
+ wp=
+ rp=DATA/T000001/physlog_T000001
+ mv DATA/T000001/physlog_T000001
if [ ! $a -eq 0 ]; then 
  echo "O caminho das imagens não está conformado com o padrâo: DATA/<ID>/T1_<ID>.nii"
  echo "Conformando..."
  echo
fi
+ '[' '!' 0 -eq 0 ']'

prefix=_RS_
+ prefix=_RS_
declare -A in in_2 in_3 in_4 in_5
+ declare -A in in_2 in_3 in_4 in_5
declare -A inpath
+ declare -A inpath
declare -A out out_2 out_3 ou_4 out_5
+ declare -A out out_2 out_3 ou_4 out_5
declare -A outpath
+ declare -A outpath

for i in $ID; do
out[$i]=RS_$i.nii
outpath[$i]=DATA/$i/
done
+ for i in '$ID'
+ out[$i]=RS_C000917.nii
+ outpath[$i]=DATA/C000917/
+ for i in '$ID'
+ out[$i]=RS_P001543.nii
+ outpath[$i]=DATA/P001543/
+ for i in '$ID'
+ out[$i]=RS_P001562.nii
+ outpath[$i]=DATA/P001562/
+ for i in '$ID'
+ out[$i]=RS_T000001.nii
+ outpath[$i]=DATA/T000001/


# AZTEC========================================================================
if [ $aztec -eq 1 ]; then
  printf "=============================AZTEC==================================\n\n"
  pwd=($PWD)
  prefix=z$prefix
  for i in $ID; do
    #inputs
    in[$i]=${out[$i]}
    in_2[$i]=RS_$i.log
    inpath[$i]=${outpath[$i]}
    #outputs
    out[$i]=$prefix$i.nii
    outpath[$i]=DATA/$i/aztec/
    echo -n "$i> "
    open.node; if [ $go -eq 1 ]; then
      #
   #  if [ ! -d "3d" ]; then  mkdir 3d ; fi && \
   #  fsl5.0-fslsplit ${in[$i]} 3d_"$i"_ -t && \
   #  mv 3d_"$i"* 3d && \
   #  gunzip 3d/3d_$i_* && \
      echo "try aztec(); catch; end" > azt_script.m && \
   #  echo "try aztec('${in[2]}',files ,500,$TR,1,$hp,'/3d') catch  quit" > azt_script.m
      matlab -nosplash -r "run azt_script.m" \
   #  rm 3d/3d* && \
   #  3dTcat -prefix ${out[$i]} -TR $((TR/1000)) 3d/aztec* && \
   #  rm 3d/aztec* 3d azt* && \ 
      &> $prefix$i.log && printf "Processamento da imagem %s realizado com sucesso! " "$i" || printf "Houve um erro no processamento da imagem %s, consulte o log %s. " "$i" "$prefix$i.log"
      #
    fi; close.node
  done
  input.error
  echo
fi
+ '[' 0 -eq 1 ']'

# SLICE TIMING CORRECTION=======================================================
printf "=======================SLICE TIMING CORRECTION====================\n\n"
+ printf '=======================SLICE TIMING CORRECTION====================\n\n'
=======================SLICE TIMING CORRECTION====================

pwd=($PWD)
+ pwd=($PWD)
prefix=t$prefix
+ prefix=t_RS_
for i in $ID; do
  #inputs
  in[$i]=${out[$i]}
  inpath[$i]=${outpath[$i]}
  #outputs
  out[$i]=$prefix$i.nii
  outpath[$i]=DATA/$i/slice_correction/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    #
    3dTshift \
      -verbose \
      -tpattern $ptn \
      -prefix ${out[$i]} \
      -Fourier \
      ${in[$i]} &> $prefix$i.log && printf "Processamento da imagem %s realizado com sucesso! " "$i" || printf "Houve um erro no processamento da imagem %s, consulte o log %s. " "$i" "$prefix$i.log"
    #
  fi; close.node
done
+ for i in '$ID'
+ in[$i]=RS_C000917.nii
+ inpath[$i]=DATA/C000917/
+ out[$i]=t_RS_C000917.nii
+ outpath[$i]=DATA/C000917/slice_correction/
+ echo -n 'C000917> '
C000917> + open.node
+ echo RS_C000917.nii
RS_C000917.nii
+ echo DATA/C000917/
DATA/C000917/
+ echo t_RS_C000917.nii
t_RS_C000917.nii
+ echo DATA/C000917/slice_correction/
DATA/C000917/slice_correction/
+ '[' -d DATA/C000917/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local e=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ b=1
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/C000917/
+ '[' 1 -eq 1 ']'
+ 3dTshift -verbose -tpattern seq+z -prefix t_RS_C000917.nii -Fourier RS_C000917.nii
+ printf 'Processamento da imagem %s realizado com sucesso! ' C000917
Processamento da imagem C000917 realizado com sucesso! + close.node
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/C000917/t_RS_C000917.log DATA/C000917/t_RS_C000917.nii DATA/C000917/slice_correction/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ '[' '!' -eq 0 ']'
./preproc.sh: line 155: [: !: integer expression expected
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/C000917/ -name 't_RS_*'
+ local 'files=DATA/C000917/slice_correction/t_RS_C000917.nii
DATA/C000917/slice_correction/t_RS_C000917.log'
+ for f in '$files'
+ mv DATA/C000917/slice_correction/t_RS_C000917.nii DATA/C000917/slice_correction/
+ for f in '$files'
+ mv DATA/C000917/slice_correction/t_RS_C000917.log DATA/C000917/slice_correction/
+ for i in '$ID'
+ in[$i]=RS_P001543.nii
+ inpath[$i]=DATA/P001543/
+ out[$i]=t_RS_P001543.nii
+ outpath[$i]=DATA/P001543/slice_correction/
+ echo -n 'P001543> '
P001543> + open.node
+ echo RS_P001543.nii
RS_P001543.nii
+ echo DATA/P001543/
DATA/P001543/
+ echo t_RS_P001543.nii
t_RS_P001543.nii
+ echo DATA/P001543/slice_correction/
DATA/P001543/slice_correction/
+ '[' -d DATA/P001543/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local e=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ b=1
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/P001543/
+ '[' 1 -eq 1 ']'
+ 3dTshift -verbose -tpattern seq+z -prefix t_RS_P001543.nii -Fourier RS_P001543.nii
+ printf 'Processamento da imagem %s realizado com sucesso! ' P001543
Processamento da imagem P001543 realizado com sucesso! + close.node
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/P001543/t_RS_P001543.log DATA/P001543/t_RS_P001543.nii DATA/P001543/slice_correction/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ '[' '!' -eq 0 ']'
./preproc.sh: line 155: [: !: integer expression expected
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/P001543/ -name 't_RS_*'
+ local 'files=DATA/P001543/slice_correction/t_RS_P001543.log
DATA/P001543/slice_correction/t_RS_P001543.nii'
+ for f in '$files'
+ mv DATA/P001543/slice_correction/t_RS_P001543.log DATA/P001543/slice_correction/
+ for f in '$files'
+ mv DATA/P001543/slice_correction/t_RS_P001543.nii DATA/P001543/slice_correction/
+ for i in '$ID'
+ in[$i]=RS_P001562.nii
+ inpath[$i]=DATA/P001562/
+ out[$i]=t_RS_P001562.nii
+ outpath[$i]=DATA/P001562/slice_correction/
+ echo -n 'P001562> '
P001562> + open.node
+ echo RS_P001562.nii
RS_P001562.nii
+ echo DATA/P001562/
DATA/P001562/
+ echo t_RS_P001562.nii
t_RS_P001562.nii
+ echo DATA/P001562/slice_correction/
DATA/P001562/slice_correction/
+ '[' -d DATA/P001562/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local e=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ b=1
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/P001562/
+ '[' 1 -eq 1 ']'
+ 3dTshift -verbose -tpattern seq+z -prefix t_RS_P001562.nii -Fourier RS_P001562.nii
+ printf 'Processamento da imagem %s realizado com sucesso! ' P001562
Processamento da imagem P001562 realizado com sucesso! + close.node
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/P001562/t_RS_P001562.log DATA/P001562/t_RS_P001562.nii DATA/P001562/slice_correction/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ '[' '!' -eq 0 ']'
./preproc.sh: line 155: [: !: integer expression expected
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/P001562/ -name 't_RS_*'
+ local 'files=DATA/P001562/slice_correction/t_RS_P001562.nii
DATA/P001562/slice_correction/t_RS_P001562.log'
+ for f in '$files'
+ mv DATA/P001562/slice_correction/t_RS_P001562.nii DATA/P001562/slice_correction/
+ for f in '$files'
+ mv DATA/P001562/slice_correction/t_RS_P001562.log DATA/P001562/slice_correction/
+ for i in '$ID'
+ in[$i]=RS_T000001.nii
+ inpath[$i]=DATA/T000001/
+ out[$i]=t_RS_T000001.nii
+ outpath[$i]=DATA/T000001/slice_correction/
+ echo -n 'T000001> '
T000001> + open.node
+ echo RS_T000001.nii
RS_T000001.nii
+ echo DATA/T000001/
DATA/T000001/
+ echo t_RS_T000001.nii
t_RS_T000001.nii
+ echo DATA/T000001/slice_correction/
DATA/T000001/slice_correction/
+ '[' -d DATA/T000001/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local e=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ b=1
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/T000001/
+ '[' 1 -eq 1 ']'
+ 3dTshift -verbose -tpattern seq+z -prefix t_RS_T000001.nii -Fourier RS_T000001.nii
+ printf 'Processamento da imagem %s realizado com sucesso! ' T000001
Processamento da imagem T000001 realizado com sucesso! + close.node
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/T000001/t_RS_T000001.log DATA/T000001/t_RS_T000001.nii DATA/T000001/slice_correction/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ '[' '!' -eq 0 ']'
./preproc.sh: line 155: [: !: integer expression expected
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/T000001/ -name 't_RS_*'
+ local 'files=DATA/T000001/slice_correction/t_RS_T000001.log
DATA/T000001/slice_correction/t_RS_T000001.nii'
+ for f in '$files'
+ mv DATA/T000001/slice_correction/t_RS_T000001.log DATA/T000001/slice_correction/
+ for f in '$files'
+ mv DATA/T000001/slice_correction/t_RS_T000001.nii DATA/T000001/slice_correction/
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


exit
+ exit
