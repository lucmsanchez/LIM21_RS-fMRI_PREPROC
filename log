#!/usr/bin/env bash

# PROCESSANDO OS ARGUMENTOS ====================================================
usage() {
    echo "Argumentos:"
    echo " $0 [ --var <txt com variáveis para análise> | --subs <ID das imagens> ]"
    echo " $0 [ -h | --help ]"
    echo
}

aztec=0
+ aztec=0


i=$(($# + 1)) # index of the first non-existing argument
+ i=5
declare -A longoptspec
+ declare -A longoptspec
longoptspec=( [config]=1 [subs]=1 )
+ longoptspec=([config]=1 [subs]=1)
optspec=":l:h:a-:"
+ optspec=:l:h:a-:
while getopts "$optspec" opt; do
while true; do
    case "${opt}" in
        -) #OPTARG is name-of-long-option or name-of-long-option=value
            if [[ ${OPTARG} =~ .*=.* ]] # with this --key=value format only one argument is possible
            then
                opt=${OPTARG/=*/}
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                if (($((longoptspec[$opt])) != 1))
                then
                    echo "Syntax error: Option '$opt' does not support this syntax." >&2
                    exit
                fi
                OPTARG=${OPTARG#*=}
            else #with this --key value1 value2 format multiple arguments are possible
                opt="$OPTARG"
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
                ((OPTIND+=longoptspec[$opt]))
                #echo $OPTIND
                ((OPTIND > i)) && {
                    echo "Syntax error: Not all required arguments for option '$opt' are given." >&2
                    exit
                }
            fi

            continue #now that opt/OPTARG are set we can process them as
            # if getopts would've given us long options
            ;;
       a|aztec)
            aztec=1
            ;;
        c|config)
          config=$OPTARG
            ;;
        s|subs)
            subs=$OPTARG
            ;;
        h|help)
            usage
            exit 0
            ;;
        ?)
            echo "Erro de sintaxe:'$OPTARG' desconhecida" >&2
            usage
            exit
            ;;
        *)
            echo "Erro de sintaxe:'$opt' desconhecida'" >&2
            usage
            exit
            ;;
    esac
break; done
done
+ getopts :l:h:a-: opt
+ true
+ case "${opt}" in
+ [[ config =~ .*=.* ]]
+ opt=config
+ (( 6 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[config] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ config=preproc.cfg
+ break
+ getopts :l:h:a-: opt
+ true
+ case "${opt}" in
+ [[ subs =~ .*=.* ]]
+ opt=subs
+ (( 4 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[subs] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ subs=preproc.sbj
+ break
+ getopts :l:h:a-: opt

# ==============================================================================

# DECLARANDO FUNÇÕES ===========================================================
check () {
  if command -v $1 > /dev/null; then
    echo "OK"
  else
    echo "Não encontrado em \$PATH"
fi
}

input.error () {
[ $ex -eq ${#ID[@]} ] && exit
}

inputs () {
    in[$i]="$1"
    in_2[$i]="$2"
    in_3[$i]="$3"
    in_4[$i]="$4"
}

outputs () {
    out[$i]="$1"
    out_2[$i]="$2"
    out_3[$i]="$3"
    out_4[$i]="$4"
}

open.node () {
  [ -d ${outpath[$i]} ] || mkdir ${outpath[$i]}
  #
  local a=0; local b=0; local c=0; local d=0; local v=0
  ex=0; go=1
  #
  for ii in ${in[$i]} ${in_2[$i]} ${in_3[$i]} ${in_4[$i]}; do
      if [ ! -f ${inpath[$i]}$ii ]; then
          echo "INPUT $ii não encontrado"
          a=$((a + 1))            
      else
          for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do
              if [ ! -f ${outpath[$i]}$iii ]; then
                  b=$((b + 1))
                else
                  d=$((d + 1))
                  [ ${outpath[$i]}$iii -ot ${inpath[$i]}$ii ] && c=$((c + 1))
              fi
          done
          [ ! $c -eq 0 ] && echo -n "INPUT $ii MODIFICADO. REFAZENDO ANÁLISE. "
      fi
  done
  #
  if [ $a -eq 0 ]; then
  #
    if [ $b -eq 0 ]; then 
      if [ ! $c -eq 0 ]; then
        for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do rm ${outpath[$i]}$iii 2> /dev/null; done
      else
          echo "OUTPUT JÁ EXISTE. PROSSEGUINDO."; go=0; ex=0
      fi
    else
        if [ ! $d -eq 0 ]; then
            echo "OUTPUT CORROMPIDO. REFAZENDO ANÁLISE."
            for ii in ${out[@]}; do rm ${outpath[$i]}$ii 2> /dev/null; done
        fi
    fi
    #
    if [ $go -eq 1 ]; then
      cd ${inpath[$i]}
    fi
  else
  go=0
  fi
  
}

close.node () {
  local e=0
  if [ $go -eq 1 ]; then  
    cd $pwd
    mv ${inpath[$i]}${prefixrs[$i]}* ${outpath[$i]} 2> /dev/null
    mv ${inpath[$i]}${prefixt1[$i]}* ${outpath[$i]} 2> /dev/null
     for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do 
      [ -f ${outpath[$i]}$iii ] ||  e=$((e + 1)) 
    done
    # 
    if [ ! $e -eq 0 ]; then
     printf "Houve um erro no processamento da imagem %s, consulte o log. \n" "$i" && ex=$((ex + 1))
    else
      printf "Processamento da imagem %s realizado com sucesso! \n" "$i"
    fi
  fi

 files1=$( find "${inpath[$i]}" -name "${prefixrs[$i]}*" )
 files2=$( find "${inpath[$i]}" -name "${prefixt1[$i]}*" )
 files=$files1$files2
  for f in $files; do
    mv $f ${outpath[$i]} 2> /dev/null
  done
}

get.info1() {
  local image=$1

  space=$(3dinfo -space $image) 
  is_oblique=$(3dinfo -is_oblique $image) 
  afniprefix=$(3dinfo -prefix $image) 
  tr=$(3dinfo -tr $image) 
  smode=$(3dinfo -smode $image) 
  orient=$(3dinfo -orient $image) 
}

get.info2 () {
  local image1=$1
  local image2=$2

  #comparações
  same_grid=$(3dinfo -same_grid $image1 $image2) 
  same_dim=$(3dinfo -same_dim $image1 $image2) 
  same_delta=$(3dinfo -same_delta $image1 $image2) 
  same_orient=$(3dinfo -same_orient $image1 $image2) 
  same_center=$(3dinfo -same_center $image1 $image2) 
  same_obl=$(3dinfo -same_obl $image1 $image2) 
}

log () {
if [ $go -eq 1 ]; then
  echo >> DATA/preproc_$i.log
  echo "ETAPA: $1  - RUNTIME: $(date)" >> DATA/preproc_$i.log
  echo >> DATA/preproc_$i.log
  echo "PREFIX: ${prefixrs[$i]}" >> DATA/preproc_$i.log
  echo "INPUT PATH: ${inpath[$i]} "  >> DATA/preproc_$i.log
  echo "INPUTS: ${in[$i]} ${in_2[$i]} ${in_3[$i]} ${in_4[$i]}" >>DATA/preproc_$i.log
  echo "OUTPUT PATH: ${outpath[$i]}" >> DATA/preproc_$i.log
  echo "OUTPUTS: ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}" >> DATA/preproc_$i.log
  echo >> DATA/preproc_$i.log
  cat ${outpath[$i]}${prefixrs[$i]}$i.log >> DATA/preproc_$i.log
fi
}
# ==============================================================================


# INÍCIO =======================================================================

fold -s <<-EOF

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: $(date)

Programas necessários:
GNU bash           ...$(check bash)
AFNI               ...$(check afni)
FSL                ...$(check fsl5.0-fast)
MATLAB             ...$(check matlab)
  SPM5
  aztec

EOF
+ fold -s
date
++ date
check bash
++ check bash
++ command -v bash
++ echo OK
check afni
++ check afni
++ command -v afni
++ echo OK
check fsl5.0-fast
++ check fsl5.0-fast
++ command -v fsl5.0-fast
++ echo OK
check matlab
++ check matlab
++ command -v matlab
++ echo OK

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: Fri Dec  9 11:24:13 BRST 2016

Programas necessários:
GNU bash           ...OK
AFNI               ...OK
FSL                ...OK
MATLAB             ...OK
  SPM5
  aztec


if ( ! command -v bash || ! command -v afni || ! command -v fsl5.0-fast  ) > /dev/null ; then
	printf "\nUm ou mais programas necessários para o pré-processamento não estão instalados (acima). Por favor instale o(s) programa(s) faltante(s) ou então verifique se estão configurados na variável de ambiente \$PATH\n\n" | fold -s
	exit
fi
+ command -v bash
+ command -v afni
+ command -v fsl5.0-fast
[ $aztec -eq 1 ] && [ ! $(command -v matlab) ] && echo "o Matlab e os plugins SPM5 e aztec são necessários para a análise e não foram encontrados. Certifique-se que eles estão instalados e configurados na variável de ambiente $PATH" | fold -s && exit 
+ '[' 0 -eq 1 ']'

if [ ! -z $config ]; then  
  if [ -f $config ]; then
    source $config
    a=0
    for var in ptn mcbase gRL gAP gIS orient template blur; do
      if [[ -z "${!var:-}" ]]; then
      echo "Variável $var não encontrada"
      a=$(($a + 1))
      fi
    done
    if [ ! $a -eq 0 ]; then
      echo "Erro: Não é possível executar o script sem as variáveis acima estarem definidas no arquivo de configuração. Encerrando"
      exit
    fi
    unset a
  else
  echo "Arquivo de configuração especificado não encontrado"
  exit
  fi
else 
  echo "O arquivo de configuração não foi especificado"
  if [ ! -f preproc.cfg ]; then
    echo "Será criado um arquivo de configuração com valores padrão: preproc.cfg"
    cat > preproc.cfg << EOL
# Variáveis RS-fMRI Preprocessing:

TR=2
hp=0
ptn=seq+z
mcbase=100
gRL=90
gAP=90
gIS=60
orient="rpi"
template="MNI152_1mm_uni+tlrc"
blur=6
EOL
exit
  else
    echo "Será usado o arquivo local preproc.cfg"
    source preproc.cfg
  fi
fi  
+ '[' '!' -z preproc.cfg ']'
+ '[' -f preproc.cfg ']'
+ source preproc.cfg
# Variáveis RS-fMRI Preprocessing:

TR=2
++ TR=2
hp=0
++ hp=0
ptn=seq+z
++ ptn=seq+z
mcbase=100
++ mcbase=100
gRL=90
++ gRL=90
gAP=90
++ gAP=90
gIS=60
++ gIS=60
orient="rpi"
++ orient=rpi
template="MNI152_1mm_uni+tlrc"
++ template=MNI152_1mm_uni+tlrc
blur=6
++ blur=6
+ a=0
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z seq+z ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 100 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 90 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 90 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 60 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z rpi ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z MNI152_1mm_uni+tlrc ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 6 ]]
+ '[' '!' 0 -eq 0 ']'
+ unset a


# informando os usuários das variáveis definidas ou defaults
fold -s <<-EOF
As variáveis que serão usadas como parametros para as análises são:
Aztec                   - Tempo de repetição(s)   => $TR
Slice timing correction - sequência de aquisição  => $ptn
Motion correction       - valor base              => $mcbase
Homogenize Grid         - tamanho da grade        => $gRL $gAP $gIS

EOF
+ fold -s
As variáveis que serão usadas como parametros para as análises são:
Aztec                   - Tempo de repetição(s)   => 2
Slice timing correction - sequência de aquisição  => seq+z
Motion correction       - valor base              => 100
Homogenize Grid         - tamanho da grade        => 90 90 60


# Checando arquivo com nome dos indivíduos
if [ ! -z $subs ]; then  
  if [ ! -f $subs ]; then
    echo "Arquivo com ID dos indivíduos especificado não encontrado"
    exit
  fi
else 
  if [ -f preproc.sbj ]; then
    subs=preproc.sbj
  else
    echo "O arquivo com ID dos indivíduos não foi especificado" 
    exit
  fi
fi  
+ '[' '!' -z preproc.sbj ']'
+ '[' '!' -f preproc.sbj ']'

ID=$(cat $subs)
cat $subs
++ cat preproc.sbj
+ ID='C000917
P001543
P001562
T000001'
echo "Lista de indivíduos para análise:"
+ echo 'Lista de indivíduos para análise:'
Lista de indivíduos para análise:
a=0
+ a=0
for i in $ID; do 
  echo -n "$i  ... " 
  if [ $(find . -name "T1_$i.nii") ] && [ $(find . -name "T1_$i.PAR") ]; then
    echo -n "T1" 
  else echo -n "(T1 não encontrado)"; a=$((a + 1))
  fi
  if [ $(find . -name "RS_$i.nii") ] && [ $(find . -name "RS_$i.PAR") ]; then
    printf " RS" 
  else echo " (RS não encontrado)"; a=$((a + 1)) 
  fi
  [ $(find . -name "z_RS_$i.nii") ] && printf " aztec"
  [ $(find . -name "t*_RS_$i.nii") ] && printf " stc"
  [ $(find . -name "rt*_RS_$i.nii") ] && printf " mc"
  printf "\n"
done
+ for i in '$ID'
+ echo -n 'C000917  ... '
C000917  ... find . -name "T1_$i.nii"
++ find . -name T1_C000917.nii
+ '[' ./DATA/C000917/T1_C000917.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_C000917.PAR
+ '[' ./DATA/C000917/T1_C000917.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_C000917.nii
+ '[' ./DATA/C000917/RS_C000917.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_C000917.PAR
+ '[' ./DATA/C000917/RS_C000917.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_C000917.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_C000917.nii'
+ '[' ./DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_C000917.nii'
+ '[' ./DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'P001543  ... '
P001543  ... find . -name "T1_$i.nii"
++ find . -name T1_P001543.nii
+ '[' ./DATA/P001543/T1_P001543.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001543.PAR
+ '[' ./DATA/P001543/T1_P001543.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001543.nii
+ '[' ./DATA/P001543/RS_P001543.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001543.PAR
+ '[' ./DATA/P001543/RS_P001543.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_P001543.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_P001543.nii'
+ '[' ./DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_P001543.nii'
+ '[' ./DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'P001562  ... '
P001562  ... find . -name "T1_$i.nii"
++ find . -name T1_P001562.nii
+ '[' ./DATA/P001562/T1_P001562.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001562.PAR
+ '[' ./DATA/P001562/T1_P001562.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001562.nii
+ '[' ./DATA/P001562/RS_P001562.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001562.PAR
+ '[' ./DATA/P001562/RS_P001562.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_P001562.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_P001562.nii'
+ '[' ./DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_P001562.nii'
+ '[' ./DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'T000001  ... '
T000001  ... find . -name "T1_$i.nii"
++ find . -name T1_T000001.nii
+ '[' ./DATA/T000001/T1_T000001.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_T000001.PAR
+ '[' ./DATA/T000001/T1_T000001.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_T000001.nii
+ '[' ./DATA/T000001/RS_T000001.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_T000001.PAR
+ '[' ./DATA/T000001/RS_T000001.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_T000001.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_T000001.nii'
+ '[' ./DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_T000001.nii'
+ '[' ./DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ printf ' mc'
 mc+ printf '\n'

echo
+ echo

if [ ! $a -eq 0 ]; then
    echo "Imagens não foram encontradas ou não estão nomeadas conforme o padrão: RS_<ID>.nii/RS_<ID>.PAR e T1_<ID>.nii/T1_<ID>" | fold -s ; echo
    exit
fi
+ '[' '!' 0 -eq 0 ']'

[ -d DATA ] || mkdir DATA
+ '[' -d DATA ']'
[ -d OUTPUT ] || mkdir OUTPUT
+ '[' -d OUTPUT ']'

unset a; a=0
+ unset a
+ a=0
for i in $ID; do
  [ -d DATA/$i ] || mkdir DATA/$i 
  [ -d OUTPUT/$i ] || mkdir OUTPUT/$i 
  for ii in T1_$i.nii T1_$i.PAR RS_$i.nii RS_$i.PAR physlog_$i; do
    [ ! -f DATA/$i/$ii ] && wp=$(find . -name $ii) && rp=DATA/$i/$ii && mv $wp $rp 2> /dev/null && a=$((a + 1))
  done
done
+ for i in '$ID'
+ '[' -d DATA/C000917 ']'
+ '[' -d OUTPUT/C000917 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/physlog_C000917 ']'
find . -name $ii
++ find . -name physlog_C000917
+ wp=
+ rp=DATA/C000917/physlog_C000917
+ mv DATA/C000917/physlog_C000917
+ for i in '$ID'
+ '[' -d DATA/P001543 ']'
+ '[' -d OUTPUT/P001543 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/physlog_P001543 ']'
find . -name $ii
++ find . -name physlog_P001543
+ wp=
+ rp=DATA/P001543/physlog_P001543
+ mv DATA/P001543/physlog_P001543
+ for i in '$ID'
+ '[' -d DATA/P001562 ']'
+ '[' -d OUTPUT/P001562 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/physlog_P001562 ']'
find . -name $ii
++ find . -name physlog_P001562
+ wp=
+ rp=DATA/P001562/physlog_P001562
+ mv DATA/P001562/physlog_P001562
+ for i in '$ID'
+ '[' -d DATA/T000001 ']'
+ '[' -d OUTPUT/T000001 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/physlog_T000001 ']'
find . -name $ii
++ find . -name physlog_T000001
+ wp=
+ rp=DATA/T000001/physlog_T000001
+ mv DATA/T000001/physlog_T000001
if [ ! $a -eq 0 ]; then 
  echo "O caminho das imagens não está conformado com o padrâo: DATA/<ID>/T1_<ID>.nii"
  echo "Conformando..."
  echo
fi
+ '[' '!' 0 -eq 0 ']'

declare -A prefixt1
+ declare -A prefixt1
declare -A prefixrs
+ declare -A prefixrs
declare -A in in_2 in_3 in_4 in_5
+ declare -A in in_2 in_3 in_4 in_5
declare -A inpath
+ declare -A inpath
declare -A out out_2 out_3 ou_4 out_5
+ declare -A out out_2 out_3 ou_4 out_5
declare -A outpath
+ declare -A outpath
for i in $ID; do
prefixrs[$i]=_RS_
prefixt1[$i]=_T1_
out[$i]=RS_$i.nii
outpath[$i]=DATA/$i/
done
+ for i in '$ID'
+ prefixrs[$i]=_RS_
+ prefixt1[$i]=_T1_
+ out[$i]=RS_C000917.nii
+ outpath[$i]=DATA/C000917/
+ for i in '$ID'
+ prefixrs[$i]=_RS_
+ prefixt1[$i]=_T1_
+ out[$i]=RS_P001543.nii
+ outpath[$i]=DATA/P001543/
+ for i in '$ID'
+ prefixrs[$i]=_RS_
+ prefixt1[$i]=_T1_
+ out[$i]=RS_P001562.nii
+ outpath[$i]=DATA/P001562/
+ for i in '$ID'
+ prefixrs[$i]=_RS_
+ prefixt1[$i]=_T1_
+ out[$i]=RS_T000001.nii
+ outpath[$i]=DATA/T000001/


# AZTEC========================================================================
if [ $aztec -eq 1 ]; then
  printf "=============================AZTEC==================================\n\n"
  pwd=($PWD)
  for i in $ID; do
    prefixrs[$i]=z${prefixrs[$i]}
    inputs "${out[$i]}" "RS_$i.log"
    inpath[$i]=${outpath[$i]}
    outputs "${prefixrs[$i]}$i.nii"
    outpath[$i]=DATA/$i/aztec/
    echo -n "$i> "
    open.node; if [ $go -eq 1 ]; then
      #
   #  if [ ! -d "3d" ]; then  mkdir 3d ; fi && \
   #  fsl5.0-fslsplit ${in[$i]} 3d_"$i"_ -t && \
   #  mv 3d_"$i"* 3d && \
   #  gunzip 3d/3d_$i_* && \
      echo "try aztec(); catch; end" > azt_script.m && \
   #  echo "try aztec('${in[2]}',files ,500,$((TR * 1000)),1,$hp,'/3d') catch  quit" > azt_script.m
      matlab -nosplash -r "run azt_script.m" \
   #  rm 3d/3d* && \
   #  3dTcat -prefix ${out[$i]} -TR $TR 3d/aztec* && \
   #  rm 3d/aztec* 3d azt* && \ 
      &> ${prefixrs[$i]}$i.log 
      #
    fi; close.node
    log "Aztec"
  done
  input.error
  echo
fi
+ '[' 0 -eq 1 ']'

# SLICE TIMING CORRECTION=======================================================
printf "=======================SLICE TIMING CORRECTION====================\n\n"
+ printf '=======================SLICE TIMING CORRECTION====================\n\n'
=======================SLICE TIMING CORRECTION====================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  prefixrs[$i]=t${prefixrs[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefixrs[$i]}$i.nii"
  outpath[$i]=DATA/$i/slice_correction/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    #
    3dTshift \
      -verbose \
      -tpattern $ptn \
      -prefix ${out[$i]} \
      -Fourier \
      ${in[$i]} &> ${prefixrs[$i]}$i.log 
    #
  fi; close.node
  log "Slice Timing Correction"
done
+ for i in '$ID'
+ prefixrs[$i]=t_RS_
+ inputs RS_C000917.nii
+ in[$i]=RS_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/
+ outputs t_RS_C000917.nii
+ out[$i]=t_RS_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/slice_correction/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/slice_correction/t_RS_C000917.nii -ot DATA/C000917/RS_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/C000917/ -name 't_RS_*'
+ files1='DATA/C000917/slice_correction/t_RS_C000917.nii
DATA/C000917/slice_correction/t_RS_C000917.log'
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/C000917/ -name '_T1_*'
+ files2=
+ files='DATA/C000917/slice_correction/t_RS_C000917.nii
DATA/C000917/slice_correction/t_RS_C000917.log'
+ for f in '$files'
+ mv DATA/C000917/slice_correction/t_RS_C000917.nii DATA/C000917/slice_correction/
+ for f in '$files'
+ mv DATA/C000917/slice_correction/t_RS_C000917.log DATA/C000917/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefixrs[$i]=t_RS_
+ inputs RS_P001543.nii
+ in[$i]=RS_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/
+ outputs t_RS_P001543.nii
+ out[$i]=t_RS_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/slice_correction/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/slice_correction/t_RS_P001543.nii -ot DATA/P001543/RS_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/P001543/ -name 't_RS_*'
+ files1='DATA/P001543/slice_correction/t_RS_P001543.log
DATA/P001543/slice_correction/t_RS_P001543.nii'
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/P001543/ -name '_T1_*'
+ files2=
+ files='DATA/P001543/slice_correction/t_RS_P001543.log
DATA/P001543/slice_correction/t_RS_P001543.nii'
+ for f in '$files'
+ mv DATA/P001543/slice_correction/t_RS_P001543.log DATA/P001543/slice_correction/
+ for f in '$files'
+ mv DATA/P001543/slice_correction/t_RS_P001543.nii DATA/P001543/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefixrs[$i]=t_RS_
+ inputs RS_P001562.nii
+ in[$i]=RS_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/
+ outputs t_RS_P001562.nii
+ out[$i]=t_RS_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/slice_correction/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/slice_correction/t_RS_P001562.nii -ot DATA/P001562/RS_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/P001562/ -name 't_RS_*'
+ files1='DATA/P001562/slice_correction/t_RS_P001562.nii
DATA/P001562/slice_correction/t_RS_P001562.log'
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/P001562/ -name '_T1_*'
+ files2=
+ files='DATA/P001562/slice_correction/t_RS_P001562.nii
DATA/P001562/slice_correction/t_RS_P001562.log'
+ for f in '$files'
+ mv DATA/P001562/slice_correction/t_RS_P001562.nii DATA/P001562/slice_correction/
+ for f in '$files'
+ mv DATA/P001562/slice_correction/t_RS_P001562.log DATA/P001562/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefixrs[$i]=t_RS_
+ inputs RS_T000001.nii
+ in[$i]=RS_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/
+ outputs t_RS_T000001.nii
+ out[$i]=t_RS_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/slice_correction/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/slice_correction/t_RS_T000001.nii -ot DATA/T000001/RS_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/T000001/ -name 't_RS_*'
+ files1='DATA/T000001/slice_correction/t_RS_T000001.log
DATA/T000001/slice_correction/t_RS_T000001.nii'
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/T000001/ -name '_T1_*'
+ files2=
+ files='DATA/T000001/slice_correction/t_RS_T000001.log
DATA/T000001/slice_correction/t_RS_T000001.nii'
+ for f in '$files'
+ mv DATA/T000001/slice_correction/t_RS_T000001.log DATA/T000001/slice_correction/
+ for f in '$files'
+ mv DATA/T000001/slice_correction/t_RS_T000001.nii DATA/T000001/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


# MOTION CORRECTION============================================================
printf "\n=========================MOTION CORRECTION=======================\n\n"
+ printf '\n=========================MOTION CORRECTION=======================\n\n'

=========================MOTION CORRECTION=======================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  prefixrs[$i]=r${prefixrs[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefixrs[$i]}$i.nii" "${prefixrs[$i]}mc_$i.1d" "${prefixrs[$i]}mcplot_$i.jpg"
  outpath[$i]=DATA/$i/motion_correction/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dvolreg \
    -prefix ${out[$i]} \
    -base 100 \
    -zpad 2 \
    -twopass \
    -Fourier \
    -verbose \
    -1Dfile ${out_2[$i]} \
    ${in[$i]} &>> ${prefixrs[$i]}$i.log && \
    1dplot \
    -jpg ${out_3[$i]} \
    -volreg -dx $TR \
    -xlabel Time \
    -thick \
    ${out_2[$i]} &>> ${prefixrs[$i]}$i.log 
  fi; close.node
  log "Motion Correction "
done
+ for i in '$ID'
+ prefixrs[$i]=rt_RS_
+ inputs t_RS_C000917.nii
+ in[$i]=t_RS_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/slice_correction/
+ outputs rt_RS_C000917.nii rt_RS_mc_C000917.1d rt_RS_mcplot_C000917.jpg
+ out[$i]=rt_RS_C000917.nii
+ out_2[$i]=rt_RS_mc_C000917.1d
+ out_3[$i]=rt_RS_mcplot_C000917.jpg
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/motion_correction/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/motion_correction/rt_RS_C000917.nii -ot DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_mc_C000917.1d ']'
+ d=2
+ '[' DATA/C000917/motion_correction/rt_RS_mc_C000917.1d -ot DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_mcplot_C000917.jpg ']'
+ d=3
+ '[' DATA/C000917/motion_correction/rt_RS_mcplot_C000917.jpg -ot DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/C000917/slice_correction/ -name 'rt_RS_*'
+ files1=
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/C000917/slice_correction/ -name '_T1_*'
+ files2=
+ files=
+ log 'Motion Correction '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefixrs[$i]=rt_RS_
+ inputs t_RS_P001543.nii
+ in[$i]=t_RS_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/slice_correction/
+ outputs rt_RS_P001543.nii rt_RS_mc_P001543.1d rt_RS_mcplot_P001543.jpg
+ out[$i]=rt_RS_P001543.nii
+ out_2[$i]=rt_RS_mc_P001543.1d
+ out_3[$i]=rt_RS_mcplot_P001543.jpg
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/motion_correction/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/motion_correction/rt_RS_P001543.nii -ot DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_mc_P001543.1d ']'
+ d=2
+ '[' DATA/P001543/motion_correction/rt_RS_mc_P001543.1d -ot DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_mcplot_P001543.jpg ']'
+ d=3
+ '[' DATA/P001543/motion_correction/rt_RS_mcplot_P001543.jpg -ot DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/P001543/slice_correction/ -name 'rt_RS_*'
+ files1=
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/P001543/slice_correction/ -name '_T1_*'
+ files2=
+ files=
+ log 'Motion Correction '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefixrs[$i]=rt_RS_
+ inputs t_RS_P001562.nii
+ in[$i]=t_RS_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/slice_correction/
+ outputs rt_RS_P001562.nii rt_RS_mc_P001562.1d rt_RS_mcplot_P001562.jpg
+ out[$i]=rt_RS_P001562.nii
+ out_2[$i]=rt_RS_mc_P001562.1d
+ out_3[$i]=rt_RS_mcplot_P001562.jpg
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/motion_correction/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/motion_correction/rt_RS_P001562.nii -ot DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_mc_P001562.1d ']'
+ d=2
+ '[' DATA/P001562/motion_correction/rt_RS_mc_P001562.1d -ot DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_mcplot_P001562.jpg ']'
+ d=3
+ '[' DATA/P001562/motion_correction/rt_RS_mcplot_P001562.jpg -ot DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/P001562/slice_correction/ -name 'rt_RS_*'
+ files1=
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/P001562/slice_correction/ -name '_T1_*'
+ files2=
+ files=
+ log 'Motion Correction '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefixrs[$i]=rt_RS_
+ inputs t_RS_T000001.nii
+ in[$i]=t_RS_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/slice_correction/
+ outputs rt_RS_T000001.nii rt_RS_mc_T000001.1d rt_RS_mcplot_T000001.jpg
+ out[$i]=rt_RS_T000001.nii
+ out_2[$i]=rt_RS_mc_T000001.1d
+ out_3[$i]=rt_RS_mcplot_T000001.jpg
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/motion_correction/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/motion_correction/rt_RS_T000001.nii -ot DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_mc_T000001.1d ']'
+ d=2
+ '[' DATA/T000001/motion_correction/rt_RS_mc_T000001.1d -ot DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_mcplot_T000001.jpg ']'
+ d=3
+ '[' DATA/T000001/motion_correction/rt_RS_mcplot_T000001.jpg -ot DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/T000001/slice_correction/ -name 'rt_RS_*'
+ files1=
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/T000001/slice_correction/ -name '_T1_*'
+ files2=
+ files=
+ log 'Motion Correction '
+ '[' 0 -eq 1 ']'
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


# DEOBLIQUE RS============================================================
printf "\n=========================DEOBLIQUE RS=======================\n\n"
+ printf '\n=========================DEOBLIQUE RS=======================\n\n'

=========================DEOBLIQUE RS=======================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  get.info1 "${outpath[$i]}${out[$i]}"; if [ $is_oblique -eq 1 ]; then 
  prefixrs[$i]=d${prefixrs[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefixrs[$i]}$i.nii"
  outpath[$i]=DATA/$i/deoblique/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dWarp \
    -verb
    -deoblique \
    -prefix  ${out[$i]} \
    ${in[$i]} &> ${prefixrs[$i]}$i.log 
  fi; close.node
  else echo "$i não é obliquo"
  log "DEOBLIQUE RS "; fi
  declare -A outrs[$i]=${prefixrs[$i]}$i.nii
done
+ for i in '$ID'
+ get.info1 DATA/C000917/motion_correction/rt_RS_C000917.nii
+ local image=DATA/C000917/motion_correction/rt_RS_C000917.nii
3dinfo -space $image
++ 3dinfo -space DATA/C000917/motion_correction/rt_RS_C000917.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/C000917/motion_correction/rt_RS_C000917.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/C000917/motion_correction/rt_RS_C000917.nii
+ afniprefix=rt_RS_C000917.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/C000917/motion_correction/rt_RS_C000917.nii
+ tr=2.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/C000917/motion_correction/rt_RS_C000917.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/C000917/motion_correction/rt_RS_C000917.nii
+ orient=RAI
+ '[' 1 -eq 1 ']'
+ prefixrs[$i]=drt_RS_
+ inputs rt_RS_C000917.nii
+ in[$i]=rt_RS_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/motion_correction/
+ outputs drt_RS_C000917.nii
+ out[$i]=drt_RS_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/deoblique/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/deoblique/drt_RS_C000917.nii ']'
+ b=1
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/C000917/motion_correction/
+ '[' 1 -eq 1 ']'
+ 3dWarp -verb
++ 3dWarp: AFNI version=AFNI_2011_12_21_1014 (Mar  6 2016) [64-bit]
++ Authored by: RW Cox
** FATAL ERROR: No transformation on command line!?
** Program compile date = Mar  6 2016
+ -deoblique -prefix drt_RS_C000917.nii rt_RS_C000917.nii
+ close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/C000917/motion_correction/drt_RS_C000917.log DATA/C000917/deoblique/
+ mv 'DATA/C000917/motion_correction/_T1_*' DATA/C000917/deoblique/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/C000917/deoblique/drt_RS_C000917.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ printf 'Houve um erro no processamento da imagem %s, consulte o log. \n' C000917
Houve um erro no processamento da imagem C000917, consulte o log. 
+ ex=1
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/C000917/motion_correction/ -name 'drt_RS_*'
+ files1=
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/C000917/motion_correction/ -name '_T1_*'
+ files2=
+ files=
+ declare -A 'outrs[C000917]=drt_RS_C000917.nii'
+ for i in '$ID'
+ get.info1 DATA/P001543/motion_correction/rt_RS_P001543.nii
+ local image=DATA/P001543/motion_correction/rt_RS_P001543.nii
3dinfo -space $image
++ 3dinfo -space DATA/P001543/motion_correction/rt_RS_P001543.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/P001543/motion_correction/rt_RS_P001543.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/P001543/motion_correction/rt_RS_P001543.nii
+ afniprefix=rt_RS_P001543.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/P001543/motion_correction/rt_RS_P001543.nii
+ tr=2.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/P001543/motion_correction/rt_RS_P001543.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/P001543/motion_correction/rt_RS_P001543.nii
+ orient=RAI
+ '[' 1 -eq 1 ']'
+ prefixrs[$i]=drt_RS_
+ inputs rt_RS_P001543.nii
+ in[$i]=rt_RS_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/motion_correction/
+ outputs drt_RS_P001543.nii
+ out[$i]=drt_RS_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/deoblique/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/deoblique/drt_RS_P001543.nii ']'
+ b=1
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/P001543/motion_correction/
+ '[' 1 -eq 1 ']'
+ 3dWarp -verb
++ 3dWarp: AFNI version=AFNI_2011_12_21_1014 (Mar  6 2016) [64-bit]
++ Authored by: RW Cox
** FATAL ERROR: No transformation on command line!?
** Program compile date = Mar  6 2016
+ -deoblique -prefix drt_RS_P001543.nii rt_RS_P001543.nii
+ close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/P001543/motion_correction/drt_RS_P001543.log DATA/P001543/deoblique/
+ mv 'DATA/P001543/motion_correction/_T1_*' DATA/P001543/deoblique/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001543/deoblique/drt_RS_P001543.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ printf 'Houve um erro no processamento da imagem %s, consulte o log. \n' P001543
Houve um erro no processamento da imagem P001543, consulte o log. 
+ ex=1
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/P001543/motion_correction/ -name 'drt_RS_*'
+ files1=
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/P001543/motion_correction/ -name '_T1_*'
+ files2=
+ files=
+ declare -A 'outrs[P001543]=drt_RS_P001543.nii'
+ for i in '$ID'
+ get.info1 DATA/P001562/motion_correction/rt_RS_P001562.nii
+ local image=DATA/P001562/motion_correction/rt_RS_P001562.nii
3dinfo -space $image
++ 3dinfo -space DATA/P001562/motion_correction/rt_RS_P001562.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/P001562/motion_correction/rt_RS_P001562.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/P001562/motion_correction/rt_RS_P001562.nii
+ afniprefix=rt_RS_P001562.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/P001562/motion_correction/rt_RS_P001562.nii
+ tr=2.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/P001562/motion_correction/rt_RS_P001562.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/P001562/motion_correction/rt_RS_P001562.nii
+ orient=RAI
+ '[' 1 -eq 1 ']'
+ prefixrs[$i]=drt_RS_
+ inputs rt_RS_P001562.nii
+ in[$i]=rt_RS_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/motion_correction/
+ outputs drt_RS_P001562.nii
+ out[$i]=drt_RS_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/deoblique/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/deoblique/drt_RS_P001562.nii ']'
+ b=1
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/P001562/motion_correction/
+ '[' 1 -eq 1 ']'
+ 3dWarp -verb
++ 3dWarp: AFNI version=AFNI_2011_12_21_1014 (Mar  6 2016) [64-bit]
++ Authored by: RW Cox
** FATAL ERROR: No transformation on command line!?
** Program compile date = Mar  6 2016
+ -deoblique -prefix drt_RS_P001562.nii rt_RS_P001562.nii
+ close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/P001562/motion_correction/drt_RS_P001562.log DATA/P001562/deoblique/
+ mv 'DATA/P001562/motion_correction/_T1_*' DATA/P001562/deoblique/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001562/deoblique/drt_RS_P001562.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ printf 'Houve um erro no processamento da imagem %s, consulte o log. \n' P001562
Houve um erro no processamento da imagem P001562, consulte o log. 
+ ex=1
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/P001562/motion_correction/ -name 'drt_RS_*'
+ files1=
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/P001562/motion_correction/ -name '_T1_*'
+ files2=
+ files=
+ declare -A 'outrs[P001562]=drt_RS_P001562.nii'
+ for i in '$ID'
+ get.info1 DATA/T000001/motion_correction/rt_RS_T000001.nii
+ local image=DATA/T000001/motion_correction/rt_RS_T000001.nii
3dinfo -space $image
++ 3dinfo -space DATA/T000001/motion_correction/rt_RS_T000001.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/T000001/motion_correction/rt_RS_T000001.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/T000001/motion_correction/rt_RS_T000001.nii
+ afniprefix=rt_RS_T000001.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/T000001/motion_correction/rt_RS_T000001.nii
+ tr=2.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/T000001/motion_correction/rt_RS_T000001.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/T000001/motion_correction/rt_RS_T000001.nii
+ orient=RAI
+ '[' 1 -eq 1 ']'
+ prefixrs[$i]=drt_RS_
+ inputs rt_RS_T000001.nii
+ in[$i]=rt_RS_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/motion_correction/
+ outputs drt_RS_T000001.nii
+ out[$i]=drt_RS_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/deoblique/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/deoblique/drt_RS_T000001.nii ']'
+ b=1
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/T000001/motion_correction/
+ '[' 1 -eq 1 ']'
+ 3dWarp -verb
++ 3dWarp: AFNI version=AFNI_2011_12_21_1014 (Mar  6 2016) [64-bit]
++ Authored by: RW Cox
** FATAL ERROR: No transformation on command line!?
** Program compile date = Mar  6 2016
+ -deoblique -prefix drt_RS_T000001.nii rt_RS_T000001.nii
+ close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/T000001/motion_correction/drt_RS_T000001.log DATA/T000001/deoblique/
+ mv 'DATA/T000001/motion_correction/_T1_*' DATA/T000001/deoblique/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/T000001/deoblique/drt_RS_T000001.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ printf 'Houve um erro no processamento da imagem %s, consulte o log. \n' T000001
Houve um erro no processamento da imagem T000001, consulte o log. 
+ ex=1
 find "${inpath[$i]}" -name "${prefixrs[$i]}*" 
++ find DATA/T000001/motion_correction/ -name 'drt_RS_*'
+ files1=
 find "${inpath[$i]}" -name "${prefixt1[$i]}*" 
++ find DATA/T000001/motion_correction/ -name '_T1_*'
+ files2=
+ files=
+ declare -A 'outrs[T000001]=drt_RS_T000001.nii'
input.error
+ input.error
+ '[' 1 -eq 1 ']'
+ exit
