#!/usr/bin/env bash

# PROCESSANDO OS ARGUMENTOS ====================================================
usage() {
    echo "Argumentos:"
    echo " $0 [ Opções ] --config <txt com variáveis para análise>  --subs <ID das imagens>" 
    echo 
    echo "Opções:"
    echo
    echo "-a | --aztec  realiza a etapa aztec"
    echo "-b | --bet    realiza o skull strip automatizado (Padrão: Manual)"
    echo
}

aztec=0
+ aztec=0
bet=0
+ bet=0

i=$(($# + 1)) # index of the first non-existing argument
+ i=6
declare -A longoptspec
+ declare -A longoptspec
longoptspec=( [config]=1 [subs]=1 )
+ longoptspec=([config]=1 [subs]=1)
optspec=":l:h:a:b:c:s-:"
+ optspec=:l:h:a:b:c:s-:
while getopts "$optspec" opt; do
while true; do
    case "${opt}" in
        -) #OPTARG is name-of-long-option or name-of-long-option=value
            if [[ ${OPTARG} =~ .*=.* ]] # with this --key=value format only one argument is possible
            then
                opt=${OPTARG/=*/}
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                if (($((longoptspec[$opt])) != 1))
                then
                    echo "Syntax error: Option '$opt' does not support this syntax." >&2
                    exit
                fi
                OPTARG=${OPTARG#*=}
            else #with this --key value1 value2 format multiple arguments are possible
                opt="$OPTARG"
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
                ((OPTIND+=longoptspec[$opt]))
                #echo $OPTIND
                ((OPTIND > i)) && {
                    echo "Syntax error: Not all required arguments for option '$opt' are given." >&2
                    exit
                }
            fi

            continue #now that opt/OPTARG are set we can process them as
            # if getopts would've given us long options
            ;;
        a|aztec)
            aztec=1
            ;;
        b|bet)
            bet=1
            ;;
        c|config)
          config=$OPTARG
            ;;
        s|subs)
            subs=$OPTARG
            ;;
        h|help)
            usage
            exit 0
            ;;
        ?)
            echo "Erro de sintaxe:'$OPTARG' desconhecida" >&2
            usage
            exit
            ;;
        *)
            echo "Erro de sintaxe:'$opt' desconhecida'" >&2
            usage
            exit
            ;;
    esac
break; done
done
+ getopts :l:h:a:b:c:s-: opt
+ true
+ case "${opt}" in
+ bet=1
+ break
+ getopts :l:h:a:b:c:s-: opt

# ==============================================================================

# DECLARANDO VARIÁVEIS ===========================================================
declare -A prefix
+ declare -A prefix
declare -A in in_2 in_3 in_4 in_5
+ declare -A in in_2 in_3 in_4 in_5
declare -A inpath
+ declare -A inpath
declare -A out out_2 out_3 ou_4 out_5
+ declare -A out out_2 out_3 ou_4 out_5
declare -A outpath
+ declare -A outpath
declare -A outrs outt1 outpathrs outpatht1 prefixrs prefixt1
+ declare -A outrs outt1 outpathrs outpatht1 prefixrs prefixt1
# ==============================================================================

# DECLARANDO FUNÇÕES ===========================================================
check () {
  if command -v $1 > /dev/null; then
    echo "OK"
  else
    echo "Não encontrado em \$PATH"
fi
}

input.error () {
[ $ex -eq ${#ID[@]} ] && exit
}

inputs () {
    in[$i]="$1"
    in_2[$i]="$2"
    in_3[$i]="$3"
    in_4[$i]="$4"
}

outputs () {
    out[$i]="$1"
    out_2[$i]="$2"
    out_3[$i]="$3"
    out_4[$i]="$4"
}

open.node () {
  [ -d ${outpath[$i]} ] || mkdir ${outpath[$i]} 2> /dev/null
  #
  local a=0; local b=0; local c=0; local d=0; local v=0
  ex=0; go=1
  #
  for ii in ${in[$i]} ${in_2[$i]} ${in_3[$i]} ${in_4[$i]}; do
      if [ ! -f ${inpath[$i]}$ii ]; then
          echo "INPUT $ii não encontrado"
          a=$((a + 1))            
      else
          for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do
              if [ ! -f ${outpath[$i]}$iii ]; then
                  b=$((b + 1))
                else
                  d=$((d + 1))
                  [ ${outpath[$i]}$iii -ot ${inpath[$i]}$ii ] && c=$((c + 1))
              fi
          done
          [ ! $c -eq 0 ] && echo -n "INPUT $ii MODIFICADO. REFAZENDO ANÁLISE. "
      fi
  done
  #
  if [ $a -eq 0 ]; then
  #
    if [ $b -eq 0 ]; then 
      if [ ! $c -eq 0 ]; then
        for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do rm ${outpath[$i]}$iii 2> /dev/null; done
      else
          echo "OUTPUT JÁ EXISTE. PROSSEGUINDO."; go=0; ex=0
      fi
    else
        if [ ! $d -eq 0 ]; then
            echo "OUTPUT CORROMPIDO. REFAZENDO ANÁLISE."
            for ii in ${out[@]}; do rm ${outpath[$i]}$ii 2> /dev/null; done
        fi
    fi
    #
    if [ $go -eq 1 ]; then
      cd ${inpath[$i]}
    fi
  else
  go=0
  fi
  
}

close.node () {
  local e=0
  if [ $go -eq 1 ]; then  
    cd $pwd
    mv ${inpath[$i]}${prefix[$i]}* ${outpath[$i]} 2> /dev/null
     for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do 
      [ -f ${outpath[$i]}$iii ] ||  e=$((e + 1)) 
    done
    # 
    if [ ! $e -eq 0 ]; then
     printf "Houve um erro no processamento da imagem %s, consulte o log. \n" "$i" && ex=$((ex + 1))
    else
      printf "Processamento da imagem %s realizado com sucesso! \n" "$i"
    fi
  fi
 cd $pwd
 files=$( find "${inpath[$i]}" -name "${prefix[$i]}*" )
  for f in $files; do
    mv $f ${outpath[$i]} 2> /dev/null
  done
}

get.info1() {
  local image=$1

  space=$(3dinfo -space $image) 
  is_oblique=$(3dinfo -is_oblique $image) 
  afniprefix=$(3dinfo -prefix $image) 
  tr=$(3dinfo -tr $image) 
  smode=$(3dinfo -smode $image) 
  orient=$(3dinfo -orient $image) 
}

get.info2 () {
  local image1=$1
  local image2=$2

  #comparações
  same_grid=$(3dinfo -same_grid $image1 $image2) 
  same_dim=$(3dinfo -same_dim $image1 $image2) 
  same_delta=$(3dinfo -same_delta $image1 $image2) 
  same_orient=$(3dinfo -same_orient $image1 $image2) 
  same_center=$(3dinfo -same_center $image1 $image2) 
  same_obl=$(3dinfo -same_obl $image1 $image2) 
}

log () {
if [ $go -eq 1 ]; then
  echo >> DATA/preproc_$i.log
  echo "ETAPA: $1  - RUNTIME: $(date)" >> DATA/preproc_$i.log
  echo >> DATA/preproc_$i.log
  echo "PREFIX: ${prefix[$i]}" >> DATA/preproc_$i.log
  echo "INPUT PATH: ${inpath[$i]} "  >> DATA/preproc_$i.log
  echo "INPUTS: ${in[$i]} ${in_2[$i]} ${in_3[$i]} ${in_4[$i]}" >>DATA/preproc_$i.log
  echo "OUTPUT PATH: ${outpath[$i]}" >> DATA/preproc_$i.log
  echo "OUTPUTS: ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}" >> DATA/preproc_$i.log
  echo >> DATA/preproc_$i.log
  cat ${outpath[$i]}${prefix[$i]}$i.log >> DATA/preproc_$i.log 2> /dev/null
fi
}

toRS () {
  outrs[$i]=${out[$i]}
  outpathrs[$i]=${outpath[$i]}
  prefixrs[$i]=${prefix[$i]}
  }

toT1 () {
  outt1[$i]=${out[$i]}
  outpatht1[$i]=${outpath[$i]}
  prefixt1[$i]=${prefix[$i]}
}

fromRS () {
  out[$i]=${outrs[$i]}
  outpath[$i]=${outpathrs[$i]}
  prefix[$i]=${prefixrs[$i]}
}

fromT1 () {
  out[$i]=${outt1[$i]}
  outpath[$i]=${outpatht1[$i]}
  prefix[$i]=${prefixt1[$i]}
}
# ==============================================================================


# INÍCIO =======================================================================

fold -s <<-EOF

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: $(date)

Programas necessários:
GNU bash           ...$(check bash)
AFNI               ...$(check afni)
FSL                ...$(check fsl5.0-fast)
MATLAB             ...$(check matlab)
  SPM5
  aztec

EOF
+ fold -s
date
++ date
check bash
++ check bash
++ command -v bash
++ echo OK
check afni
++ check afni
++ command -v afni
++ echo OK
check fsl5.0-fast
++ check fsl5.0-fast
++ command -v fsl5.0-fast
++ echo OK
check matlab
++ check matlab
++ command -v matlab
++ echo OK

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: Tue Dec 13 14:39:40 BRST 2016

Programas necessários:
GNU bash           ...OK
AFNI               ...OK
FSL                ...OK
MATLAB             ...OK
  SPM5
  aztec


if ( ! command -v bash || ! command -v afni || ! command -v fsl5.0-fast  ) > /dev/null ; then
	printf "\nUm ou mais programas necessários para o pré-processamento não estão instalados (acima). Por favor instale o(s) programa(s) faltante(s) ou então verifique se estão configurados na variável de ambiente \$PATH\n\n" | fold -s
	exit
fi
+ command -v bash
+ command -v afni
+ command -v fsl5.0-fast
[ $aztec -eq 1 ] && [ ! $(command -v matlab) ] && echo "o Matlab e os plugins SPM5 e aztec são necessários para a análise e não foram encontrados. Certifique-se que eles estão instalados e configurados na variável de ambiente $PATH" | fold -s && exit 
+ '[' 0 -eq 1 ']'

if [ ! -z $config ]; then  
  if [ -f $config ]; then
    source $config
    a=0
    for var in ptn mcbase gRL gAP gIS TR template blur fslpath; do
      if [[ -z "${!var:-}" ]]; then
      echo "Variável $var não encontrada"
      a=$(($a + 1))
      fi
    done
    if [ ! $a -eq 0 ]; then
      echo "Erro: Não é possível executar o script sem as variáveis acima estarem definidas no arquivo de configuração. Encerrando"
      exit
    fi
    unset a
  else
  echo "Arquivo de configuração especificado não encontrado"
  exit
  fi
else 
  echo "O arquivo de configuração não foi especificado"
  if [ ! -f preproc.cfg ]; then
    echo "Será criado um arquivo de configuração com valores padrão: preproc.cfg"
    cat > preproc.cfg << EOL
# Variáveis RS-fMRI Preprocessing:

fslpath=/usr/share/fsl/5.0/bin/
TR=2
hp=0
ptn=seq+z
mcbase=100
gRL=90
gAP=90
gIS=60
template="MNI152_1mm_uni+tlrc"
blur=6
EOL
exit
  else
    echo "Será usado o arquivo local preproc.cfg"
    source preproc.cfg
  fi
fi  
+ '[' '!' -z ']'
+ echo 'O arquivo de configuração não foi especificado'
O arquivo de configuração não foi especificado
+ '[' '!' -f preproc.cfg ']'
+ echo 'Será usado o arquivo local preproc.cfg'
Será usado o arquivo local preproc.cfg
+ source preproc.cfg
# Variáveis RS-fMRI Preprocessing:

fslpath=/usr/share/fsl/5.0/bin/
++ fslpath=/usr/share/fsl/5.0/bin/
TR=2
++ TR=2
ptn=seq+z
++ ptn=seq+z
mcbase=100
++ mcbase=100
gRL=90
++ gRL=90
gAP=90
++ gAP=90
gIS=60
++ gIS=60
template="MNI152_1mm_uni+tlrc"
++ template=MNI152_1mm_uni+tlrc
blur=6
++ blur=6


# informando os usuários das variáveis definidas ou defaults
fold -s <<-EOF
As variáveis que serão usadas como parametros para as análises são:
Aztec                   - Tempo de repetição(s)   => $TR
Slice timing correction - sequência de aquisição  => $ptn
Motion correction       - valor base              => $mcbase
Homogenize Grid         - tamanho da grade        => $gRL $gAP $gIS

TEMPLATE: $template

EOF
+ fold -s
As variáveis que serão usadas como parametros para as análises são:
Aztec                   - Tempo de repetição(s)   => 2
Slice timing correction - sequência de aquisição  => seq+z
Motion correction       - valor base              => 100
Homogenize Grid         - tamanho da grade        => 90 90 60

TEMPLATE: MNI152_1mm_uni+tlrc


# Checando arquivo com nome dos indivíduos
if [ ! -z $subs ]; then  
  if [ ! -f $subs ]; then
    echo "Arquivo com ID dos indivíduos especificado não encontrado"
    exit
  fi
else 
  if [ -f preproc.sbj ]; then
    subs=preproc.sbj
  else
    echo "O arquivo com ID dos indivíduos não foi especificado" 
    exit
  fi
fi  
+ '[' '!' -z ']'
+ '[' -f preproc.sbj ']'
+ subs=preproc.sbj

ID=$(cat $subs)
cat $subs
++ cat preproc.sbj
+ ID='C000917
P001543
P001562
T000001'
echo "Lista de indivíduos para análise:"
+ echo 'Lista de indivíduos para análise:'
Lista de indivíduos para análise:
a=0
+ a=0
for i in $ID; do 
  echo -n "$i  ... " 
  if [ $(find . -name "T1_$i.nii") ] && [ $(find . -name "T1_$i.PAR") ]; then
    echo -n "T1" 
  else echo -n "(T1 não encontrado)"; a=$((a + 1))
  fi
  if [ $(find . -name "RS_$i.nii") ] && [ $(find . -name "RS_$i.PAR") ]; then
    printf " RS" 
  else echo " (RS não encontrado)"; a=$((a + 1)) 
  fi
  [ $(find . -name "z_RS_$i.nii") ] && printf " aztec"
  [ $(find . -name "t*_RS_$i.nii") ] && printf " stc"
  [ $(find . -name "rt*_RS_$i.nii") ] && printf " mc"
  printf "\n"
done
+ for i in '$ID'
+ echo -n 'C000917  ... '
C000917  ... find . -name "T1_$i.nii"
++ find . -name T1_C000917.nii
+ '[' ./DATA/C000917/T1_C000917.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_C000917.PAR
+ '[' ./DATA/C000917/T1_C000917.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_C000917.nii
+ '[' ./DATA/C000917/RS_C000917.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_C000917.PAR
+ '[' ./DATA/C000917/RS_C000917.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_C000917.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_C000917.nii'
+ '[' ./DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_C000917.nii'
+ '[' ./DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'P001543  ... '
P001543  ... find . -name "T1_$i.nii"
++ find . -name T1_P001543.nii
+ '[' ./DATA/P001543/T1_P001543.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001543.PAR
+ '[' ./DATA/P001543/T1_P001543.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001543.nii
+ '[' ./DATA/P001543/RS_P001543.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001543.PAR
+ '[' ./DATA/P001543/RS_P001543.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_P001543.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_P001543.nii'
+ '[' ./DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_P001543.nii'
+ '[' ./DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'P001562  ... '
P001562  ... find . -name "T1_$i.nii"
++ find . -name T1_P001562.nii
+ '[' ./DATA/P001562/T1_P001562.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001562.PAR
+ '[' ./DATA/P001562/T1_P001562.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001562.nii
+ '[' ./DATA/P001562/RS_P001562.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001562.PAR
+ '[' ./DATA/P001562/RS_P001562.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_P001562.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_P001562.nii'
+ '[' ./DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_P001562.nii'
+ '[' ./DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'T000001  ... '
T000001  ... find . -name "T1_$i.nii"
++ find . -name T1_T000001.nii
+ '[' ./DATA/T000001/T1_T000001.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_T000001.PAR
+ '[' ./DATA/T000001/T1_T000001.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_T000001.nii
+ '[' ./DATA/T000001/RS_T000001.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_T000001.PAR
+ '[' ./DATA/T000001/RS_T000001.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_T000001.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_T000001.nii'
+ '[' ./DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_T000001.nii'
+ '[' ./DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ printf ' mc'
 mc+ printf '\n'

echo
+ echo

if [ ! $a -eq 0 ]; then
    echo "Imagens não foram encontradas ou não estão nomeadas conforme o padrão: RS_<ID>.nii/RS_<ID>.PAR e T1_<ID>.nii/T1_<ID>" | fold -s ; echo
    exit
fi
+ '[' '!' 0 -eq 0 ']'

# BUSCANDO O TEMPLATE
cp /usr/share/afni/atlases/"$template"* . 2>devnull
+ cp /usr/share/afni/atlases/MNI152_1mm_uni+tlrc.BRIK.gz /usr/share/afni/atlases/MNI152_1mm_uni+tlrc.HEAD .
temp=$(find . -name "$template*")
find . -name "$template*"
++ find . -name 'MNI152_1mm_uni+tlrc*'
+ temp='./MNI152_1mm_uni+tlrc.HEAD
./template/MNI152_1mm_uni+tlrc.HEAD
./template/MNI152_1mm_uni+tlrc.BRIK.gz
./MNI152_1mm_uni+tlrc.BRIK.gz'
if [ ! -z "$temp" ];then
  [ ! -d template ] && mkdir template 
  for tp in $temp; do
    mv -f $tp template 2> /dev/null
  done
else
  echo "Template $template não encontrado." && exit
fi
+ '[' '!' -z './MNI152_1mm_uni+tlrc.HEAD
./template/MNI152_1mm_uni+tlrc.HEAD
./template/MNI152_1mm_uni+tlrc.BRIK.gz
./MNI152_1mm_uni+tlrc.BRIK.gz' ']'
+ '[' '!' -d template ']'
+ for tp in '$temp'
+ mv -f ./MNI152_1mm_uni+tlrc.HEAD template
+ for tp in '$temp'
+ mv -f ./template/MNI152_1mm_uni+tlrc.HEAD template
+ for tp in '$temp'
+ mv -f ./template/MNI152_1mm_uni+tlrc.BRIK.gz template
+ for tp in '$temp'
+ mv -f ./MNI152_1mm_uni+tlrc.BRIK.gz template

[ -d DATA ] || mkdir DATA
+ '[' -d DATA ']'
[ -d OUTPUT ] || mkdir OUTPUT
+ '[' -d OUTPUT ']'

unset a; a=0
+ unset a
+ a=0
for i in $ID; do
  [ -d DATA/$i ] || mkdir DATA/$i 
  [ -d OUTPUT/$i ] || mkdir OUTPUT/$i 
  for ii in T1_$i.nii T1_$i.PAR RS_$i.nii RS_$i.PAR physlog_$i; do
    [ ! -f DATA/$i/$ii ] && wp=$(find . -name $ii) && rp=DATA/$i/$ii && mv $wp $rp 2> /dev/null && a=$((a + 1))
  done
done
+ for i in '$ID'
+ '[' -d DATA/C000917 ']'
+ '[' -d OUTPUT/C000917 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/physlog_C000917 ']'
find . -name $ii
++ find . -name physlog_C000917
+ wp=
+ rp=DATA/C000917/physlog_C000917
+ mv DATA/C000917/physlog_C000917
+ for i in '$ID'
+ '[' -d DATA/P001543 ']'
+ '[' -d OUTPUT/P001543 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/physlog_P001543 ']'
find . -name $ii
++ find . -name physlog_P001543
+ wp=
+ rp=DATA/P001543/physlog_P001543
+ mv DATA/P001543/physlog_P001543
+ for i in '$ID'
+ '[' -d DATA/P001562 ']'
+ '[' -d OUTPUT/P001562 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/physlog_P001562 ']'
find . -name $ii
++ find . -name physlog_P001562
+ wp=
+ rp=DATA/P001562/physlog_P001562
+ mv DATA/P001562/physlog_P001562
+ for i in '$ID'
+ '[' -d DATA/T000001 ']'
+ '[' -d OUTPUT/T000001 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/physlog_T000001 ']'
find . -name $ii
++ find . -name physlog_T000001
+ wp=
+ rp=DATA/T000001/physlog_T000001
+ mv DATA/T000001/physlog_T000001
if [ ! $a -eq 0 ]; then 
  echo "O caminho das imagens não está conformado com o padrâo: DATA/<ID>/T1_<ID>.nii"
  echo "Conformando..."
  echo
fi
+ '[' '!' 0 -eq 0 ']'


for i in $ID; do
prefix[$i]=_RS_
prefixt1[$i]=_T1_
out[$i]=RS_$i.nii
outpath[$i]=DATA/$i/
done
+ for i in '$ID'
+ prefix[$i]=_RS_
+ prefixt1[$i]=_T1_
+ out[$i]=RS_C000917.nii
+ outpath[$i]=DATA/C000917/
+ for i in '$ID'
+ prefix[$i]=_RS_
+ prefixt1[$i]=_T1_
+ out[$i]=RS_P001543.nii
+ outpath[$i]=DATA/P001543/
+ for i in '$ID'
+ prefix[$i]=_RS_
+ prefixt1[$i]=_T1_
+ out[$i]=RS_P001562.nii
+ outpath[$i]=DATA/P001562/
+ for i in '$ID'
+ prefix[$i]=_RS_
+ prefixt1[$i]=_T1_
+ out[$i]=RS_T000001.nii
+ outpath[$i]=DATA/T000001/


# AZTEC========================================================================
if [ $aztec -eq 1 ]; then
  printf "=============================AZTEC==================================\n\n"
  pwd=($PWD)
  for i in $ID; do
    prefix[$i]=z${prefix[$i]}
    inputs "${out[$i]}" "RS_$i.log"
    inpath[$i]=${outpath[$i]}
    outputs "${prefix[$i]}$i.nii"
    outpath[$i]=DATA/$i/aztec/
    echo -n "$i> "
    open.node; if [ $go -eq 1 ]; then
      #
   #  if [ ! -d "3d" ]; then  mkdir 3d ; fi && \
   #  fsl5.0-fslsplit ${in[$i]} 3d_"$i"_ -t && \
   #  mv 3d_"$i"* 3d && \
   #  gunzip 3d/3d_$i_* && \
      echo "try aztec(); catch; end" > azt_script.m && \
   #  echo "try aztec('${in[2]}',files ,500,$((TR * 1000)),1,$hp,'/3d') catch  quit" > azt_script.m
      matlab -nosplash -r "run azt_script.m" \
   #  rm 3d/3d* && \
   #  3dTcat -prefix ${out[$i]} -TR $TR 3d/aztec* && \
   #  rm 3d/aztec* 3d azt* && \ 
     &> ${prefix[$i]}$i.log 
      #
    fi; close.node
    log "Aztec"
  done
  input.error
  echo
fi
+ '[' 0 -eq 1 ']'

# SLICE TIMING CORRECTION=======================================================
printf "=======================SLICE TIMING CORRECTION====================\n\n"
+ printf '=======================SLICE TIMING CORRECTION====================\n\n'
=======================SLICE TIMING CORRECTION====================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  prefix[$i]=t${prefix[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefix[$i]}$i.nii"
  outpath[$i]=DATA/$i/slice_correction/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    #
    3dTshift \
      -verbose \
      -tpattern $ptn \
      -prefix ${out[$i]} \
      -Fourier \
      ${in[$i]} &> ${prefix[$i]}$i.log 
    #
  fi; close.node
  log "Slice Timing Correction"
done
+ for i in '$ID'
+ prefix[$i]=t_RS_
+ inputs RS_C000917.nii
+ in[$i]=RS_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/
+ outputs t_RS_C000917.nii
+ out[$i]=t_RS_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/slice_correction/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/slice_correction/t_RS_C000917.nii -ot DATA/C000917/RS_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/ -name 't_RS_*'
+ files='DATA/C000917/slice_correction/t_RS_C000917.nii
DATA/C000917/slice_correction/t_RS_C000917.log'
+ for f in '$files'
+ mv DATA/C000917/slice_correction/t_RS_C000917.nii DATA/C000917/slice_correction/
+ for f in '$files'
+ mv DATA/C000917/slice_correction/t_RS_C000917.log DATA/C000917/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=t_RS_
+ inputs RS_P001543.nii
+ in[$i]=RS_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/
+ outputs t_RS_P001543.nii
+ out[$i]=t_RS_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/slice_correction/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/slice_correction/t_RS_P001543.nii -ot DATA/P001543/RS_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/ -name 't_RS_*'
+ files='DATA/P001543/slice_correction/t_RS_P001543.log
DATA/P001543/slice_correction/t_RS_P001543.nii'
+ for f in '$files'
+ mv DATA/P001543/slice_correction/t_RS_P001543.log DATA/P001543/slice_correction/
+ for f in '$files'
+ mv DATA/P001543/slice_correction/t_RS_P001543.nii DATA/P001543/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=t_RS_
+ inputs RS_P001562.nii
+ in[$i]=RS_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/
+ outputs t_RS_P001562.nii
+ out[$i]=t_RS_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/slice_correction/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/slice_correction/t_RS_P001562.nii -ot DATA/P001562/RS_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/ -name 't_RS_*'
+ files='DATA/P001562/slice_correction/t_RS_P001562.nii
DATA/P001562/slice_correction/t_RS_P001562.log'
+ for f in '$files'
+ mv DATA/P001562/slice_correction/t_RS_P001562.nii DATA/P001562/slice_correction/
+ for f in '$files'
+ mv DATA/P001562/slice_correction/t_RS_P001562.log DATA/P001562/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=t_RS_
+ inputs RS_T000001.nii
+ in[$i]=RS_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/
+ outputs t_RS_T000001.nii
+ out[$i]=t_RS_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/slice_correction/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/slice_correction/t_RS_T000001.nii -ot DATA/T000001/RS_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/ -name 't_RS_*'
+ files='DATA/T000001/slice_correction/t_RS_T000001.log
DATA/T000001/slice_correction/t_RS_T000001.nii'
+ for f in '$files'
+ mv DATA/T000001/slice_correction/t_RS_T000001.log DATA/T000001/slice_correction/
+ for f in '$files'
+ mv DATA/T000001/slice_correction/t_RS_T000001.nii DATA/T000001/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


# MOTION CORRECTION============================================================
printf "\n=========================MOTION CORRECTION=======================\n\n"
+ printf '\n=========================MOTION CORRECTION=======================\n\n'

=========================MOTION CORRECTION=======================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  prefix[$i]=r${prefix[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefix[$i]}$i.nii" "${prefix[$i]}mc_$i.1d" "${prefix[$i]}mcplot_$i.jpg"
  outpath[$i]=DATA/$i/motion_correction/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dvolreg \
    -prefix ${out[$i]} \
    -base 100 \
    -zpad 2 \
    -twopass \
    -Fourier \
    -verbose \
    -1Dfile ${out_2[$i]} \
    ${in[$i]} &>> ${prefix[$i]}$i.log && \
    1dplot \
    -jpg ${out_3[$i]} \
    -volreg -dx $TR \
    -xlabel Time \
    -thick \
    ${out_2[$i]} &>> ${prefix[$i]}$i.log 
  fi; close.node
  log "Motion Correction "
done
+ for i in '$ID'
+ prefix[$i]=rt_RS_
+ inputs t_RS_C000917.nii
+ in[$i]=t_RS_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/slice_correction/
+ outputs rt_RS_C000917.nii rt_RS_mc_C000917.1d rt_RS_mcplot_C000917.jpg
+ out[$i]=rt_RS_C000917.nii
+ out_2[$i]=rt_RS_mc_C000917.1d
+ out_3[$i]=rt_RS_mcplot_C000917.jpg
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/motion_correction/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/motion_correction/rt_RS_C000917.nii -ot DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_mc_C000917.1d ']'
+ d=2
+ '[' DATA/C000917/motion_correction/rt_RS_mc_C000917.1d -ot DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_mcplot_C000917.jpg ']'
+ d=3
+ '[' DATA/C000917/motion_correction/rt_RS_mcplot_C000917.jpg -ot DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/slice_correction/ -name 'rt_RS_*'
+ files=
+ log 'Motion Correction '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=rt_RS_
+ inputs t_RS_P001543.nii
+ in[$i]=t_RS_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/slice_correction/
+ outputs rt_RS_P001543.nii rt_RS_mc_P001543.1d rt_RS_mcplot_P001543.jpg
+ out[$i]=rt_RS_P001543.nii
+ out_2[$i]=rt_RS_mc_P001543.1d
+ out_3[$i]=rt_RS_mcplot_P001543.jpg
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/motion_correction/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/motion_correction/rt_RS_P001543.nii -ot DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_mc_P001543.1d ']'
+ d=2
+ '[' DATA/P001543/motion_correction/rt_RS_mc_P001543.1d -ot DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_mcplot_P001543.jpg ']'
+ d=3
+ '[' DATA/P001543/motion_correction/rt_RS_mcplot_P001543.jpg -ot DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/slice_correction/ -name 'rt_RS_*'
+ files=
+ log 'Motion Correction '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=rt_RS_
+ inputs t_RS_P001562.nii
+ in[$i]=t_RS_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/slice_correction/
+ outputs rt_RS_P001562.nii rt_RS_mc_P001562.1d rt_RS_mcplot_P001562.jpg
+ out[$i]=rt_RS_P001562.nii
+ out_2[$i]=rt_RS_mc_P001562.1d
+ out_3[$i]=rt_RS_mcplot_P001562.jpg
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/motion_correction/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/motion_correction/rt_RS_P001562.nii -ot DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_mc_P001562.1d ']'
+ d=2
+ '[' DATA/P001562/motion_correction/rt_RS_mc_P001562.1d -ot DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_mcplot_P001562.jpg ']'
+ d=3
+ '[' DATA/P001562/motion_correction/rt_RS_mcplot_P001562.jpg -ot DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/slice_correction/ -name 'rt_RS_*'
+ files=
+ log 'Motion Correction '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=rt_RS_
+ inputs t_RS_T000001.nii
+ in[$i]=t_RS_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/slice_correction/
+ outputs rt_RS_T000001.nii rt_RS_mc_T000001.1d rt_RS_mcplot_T000001.jpg
+ out[$i]=rt_RS_T000001.nii
+ out_2[$i]=rt_RS_mc_T000001.1d
+ out_3[$i]=rt_RS_mcplot_T000001.jpg
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/motion_correction/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/motion_correction/rt_RS_T000001.nii -ot DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_mc_T000001.1d ']'
+ d=2
+ '[' DATA/T000001/motion_correction/rt_RS_mc_T000001.1d -ot DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_mcplot_T000001.jpg ']'
+ d=3
+ '[' DATA/T000001/motion_correction/rt_RS_mcplot_T000001.jpg -ot DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/slice_correction/ -name 'rt_RS_*'
+ files=
+ log 'Motion Correction '
+ '[' 0 -eq 1 ']'
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


# DEOBLIQUE RS============================================================
printf "\n=========================DEOBLIQUE RS=======================\n\n"
+ printf '\n=========================DEOBLIQUE RS=======================\n\n'

=========================DEOBLIQUE RS=======================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  get.info1 "${outpath[$i]}${out[$i]}"; if [ $is_oblique -eq 1 ]; then 
  prefix[$i]=d${prefix[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefix[$i]}$i.nii"
  outpath[$i]=DATA/$i/deoblique/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dWarp \
    -verb \
    -deoblique \
    -prefix  ${out[$i]} \
    ${in[$i]} &> ${prefix[$i]}$i.log 
  fi; close.node
  else echo "$i não é obliquo"
  log "DEOBLIQUE RS "; fi
  toRS
done
+ for i in '$ID'
+ get.info1 DATA/C000917/motion_correction/rt_RS_C000917.nii
+ local image=DATA/C000917/motion_correction/rt_RS_C000917.nii
3dinfo -space $image
++ 3dinfo -space DATA/C000917/motion_correction/rt_RS_C000917.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/C000917/motion_correction/rt_RS_C000917.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/C000917/motion_correction/rt_RS_C000917.nii
+ afniprefix=rt_RS_C000917.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/C000917/motion_correction/rt_RS_C000917.nii
+ tr=2.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/C000917/motion_correction/rt_RS_C000917.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/C000917/motion_correction/rt_RS_C000917.nii
+ orient=RAI
+ '[' 1 -eq 1 ']'
+ prefix[$i]=drt_RS_
+ inputs rt_RS_C000917.nii
+ in[$i]=rt_RS_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/motion_correction/
+ outputs drt_RS_C000917.nii
+ out[$i]=drt_RS_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/deoblique/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/deoblique/drt_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/deoblique/drt_RS_C000917.nii -ot DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/motion_correction/ -name 'drt_RS_*'
+ files=
+ toRS
+ outrs[$i]=drt_RS_C000917.nii
+ outpathrs[$i]=DATA/C000917/deoblique/
+ prefixrs[$i]=drt_RS_
+ for i in '$ID'
+ get.info1 DATA/P001543/motion_correction/rt_RS_P001543.nii
+ local image=DATA/P001543/motion_correction/rt_RS_P001543.nii
3dinfo -space $image
++ 3dinfo -space DATA/P001543/motion_correction/rt_RS_P001543.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/P001543/motion_correction/rt_RS_P001543.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/P001543/motion_correction/rt_RS_P001543.nii
+ afniprefix=rt_RS_P001543.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/P001543/motion_correction/rt_RS_P001543.nii
+ tr=2.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/P001543/motion_correction/rt_RS_P001543.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/P001543/motion_correction/rt_RS_P001543.nii
+ orient=RAI
+ '[' 1 -eq 1 ']'
+ prefix[$i]=drt_RS_
+ inputs rt_RS_P001543.nii
+ in[$i]=rt_RS_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/motion_correction/
+ outputs drt_RS_P001543.nii
+ out[$i]=drt_RS_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/deoblique/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/deoblique/drt_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/deoblique/drt_RS_P001543.nii -ot DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/motion_correction/ -name 'drt_RS_*'
+ files=
+ toRS
+ outrs[$i]=drt_RS_P001543.nii
+ outpathrs[$i]=DATA/P001543/deoblique/
+ prefixrs[$i]=drt_RS_
+ for i in '$ID'
+ get.info1 DATA/P001562/motion_correction/rt_RS_P001562.nii
+ local image=DATA/P001562/motion_correction/rt_RS_P001562.nii
3dinfo -space $image
++ 3dinfo -space DATA/P001562/motion_correction/rt_RS_P001562.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/P001562/motion_correction/rt_RS_P001562.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/P001562/motion_correction/rt_RS_P001562.nii
+ afniprefix=rt_RS_P001562.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/P001562/motion_correction/rt_RS_P001562.nii
+ tr=2.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/P001562/motion_correction/rt_RS_P001562.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/P001562/motion_correction/rt_RS_P001562.nii
+ orient=RAI
+ '[' 1 -eq 1 ']'
+ prefix[$i]=drt_RS_
+ inputs rt_RS_P001562.nii
+ in[$i]=rt_RS_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/motion_correction/
+ outputs drt_RS_P001562.nii
+ out[$i]=drt_RS_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/deoblique/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/deoblique/drt_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/deoblique/drt_RS_P001562.nii -ot DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/motion_correction/ -name 'drt_RS_*'
+ files=
+ toRS
+ outrs[$i]=drt_RS_P001562.nii
+ outpathrs[$i]=DATA/P001562/deoblique/
+ prefixrs[$i]=drt_RS_
+ for i in '$ID'
+ get.info1 DATA/T000001/motion_correction/rt_RS_T000001.nii
+ local image=DATA/T000001/motion_correction/rt_RS_T000001.nii
3dinfo -space $image
++ 3dinfo -space DATA/T000001/motion_correction/rt_RS_T000001.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/T000001/motion_correction/rt_RS_T000001.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/T000001/motion_correction/rt_RS_T000001.nii
+ afniprefix=rt_RS_T000001.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/T000001/motion_correction/rt_RS_T000001.nii
+ tr=2.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/T000001/motion_correction/rt_RS_T000001.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/T000001/motion_correction/rt_RS_T000001.nii
+ orient=RAI
+ '[' 1 -eq 1 ']'
+ prefix[$i]=drt_RS_
+ inputs rt_RS_T000001.nii
+ in[$i]=rt_RS_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/motion_correction/
+ outputs drt_RS_T000001.nii
+ out[$i]=drt_RS_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/deoblique/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/deoblique/drt_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/deoblique/drt_RS_T000001.nii -ot DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/motion_correction/ -name 'drt_RS_*'
+ files=
+ toRS
+ outrs[$i]=drt_RS_T000001.nii
+ outpathrs[$i]=DATA/T000001/deoblique/
+ prefixrs[$i]=drt_RS_
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


# DEOBLIQUE T1============================================================
printf "\n=========================DEOBLIQUE T1=======================\n\n"
+ printf '\n=========================DEOBLIQUE T1=======================\n\n'

=========================DEOBLIQUE T1=======================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  get.info1 "DATA/$i/T1_$i.nii"; if [ $is_oblique -eq 1 ]; then 
  prefix[$i]=d_T1_
  inputs "T1_$i.nii"
  inpath[$i]=DATA/$i/
  outputs "${prefix[$i]}$i.nii"
  outpath[$i]=DATA/$i/deoblique/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dWarp \
    -verb \
    -deoblique \
    -prefix  ${out[$i]} \
    ${in[$i]} &> ${prefix[$i]}$i.log 
  fi; close.node
  else echo "$i não é obliquo"
  log "DEOBLIQUE T1 "; fi
  toT1
done 
+ for i in '$ID'
+ get.info1 DATA/C000917/T1_C000917.nii
+ local image=DATA/C000917/T1_C000917.nii
3dinfo -space $image
++ 3dinfo -space DATA/C000917/T1_C000917.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/C000917/T1_C000917.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/C000917/T1_C000917.nii
+ afniprefix=T1_C000917.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/C000917/T1_C000917.nii
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/C000917/T1_C000917.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/C000917/T1_C000917.nii
+ orient=ASL
+ '[' 1 -eq 1 ']'
+ prefix[$i]=d_T1_
+ inputs T1_C000917.nii
+ in[$i]=T1_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/
+ outputs d_T1_C000917.nii
+ out[$i]=d_T1_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/deoblique/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/T1_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/deoblique/d_T1_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/deoblique/d_T1_C000917.nii -ot DATA/C000917/T1_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/ -name 'd_T1_*'
+ files='DATA/C000917/deoblique/d_T1_C000917.nii
DATA/C000917/deoblique/d_T1_C000917.log'
+ for f in '$files'
+ mv DATA/C000917/deoblique/d_T1_C000917.nii DATA/C000917/deoblique/
+ for f in '$files'
+ mv DATA/C000917/deoblique/d_T1_C000917.log DATA/C000917/deoblique/
+ toT1
+ outt1[$i]=d_T1_C000917.nii
+ outpatht1[$i]=DATA/C000917/deoblique/
+ prefixt1[$i]=d_T1_
+ for i in '$ID'
+ get.info1 DATA/P001543/T1_P001543.nii
+ local image=DATA/P001543/T1_P001543.nii
3dinfo -space $image
++ 3dinfo -space DATA/P001543/T1_P001543.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/P001543/T1_P001543.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/P001543/T1_P001543.nii
+ afniprefix=T1_P001543.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/P001543/T1_P001543.nii
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/P001543/T1_P001543.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/P001543/T1_P001543.nii
+ orient=ASL
+ '[' 1 -eq 1 ']'
+ prefix[$i]=d_T1_
+ inputs T1_P001543.nii
+ in[$i]=T1_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/
+ outputs d_T1_P001543.nii
+ out[$i]=d_T1_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/deoblique/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/T1_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/deoblique/d_T1_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/deoblique/d_T1_P001543.nii -ot DATA/P001543/T1_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/ -name 'd_T1_*'
+ files='DATA/P001543/deoblique/d_T1_P001543.nii
DATA/P001543/deoblique/d_T1_P001543.log'
+ for f in '$files'
+ mv DATA/P001543/deoblique/d_T1_P001543.nii DATA/P001543/deoblique/
+ for f in '$files'
+ mv DATA/P001543/deoblique/d_T1_P001543.log DATA/P001543/deoblique/
+ toT1
+ outt1[$i]=d_T1_P001543.nii
+ outpatht1[$i]=DATA/P001543/deoblique/
+ prefixt1[$i]=d_T1_
+ for i in '$ID'
+ get.info1 DATA/P001562/T1_P001562.nii
+ local image=DATA/P001562/T1_P001562.nii
3dinfo -space $image
++ 3dinfo -space DATA/P001562/T1_P001562.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/P001562/T1_P001562.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/P001562/T1_P001562.nii
+ afniprefix=T1_P001562.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/P001562/T1_P001562.nii
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/P001562/T1_P001562.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/P001562/T1_P001562.nii
+ orient=ASL
+ '[' 1 -eq 1 ']'
+ prefix[$i]=d_T1_
+ inputs T1_P001562.nii
+ in[$i]=T1_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/
+ outputs d_T1_P001562.nii
+ out[$i]=d_T1_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/deoblique/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/T1_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/deoblique/d_T1_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/deoblique/d_T1_P001562.nii -ot DATA/P001562/T1_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/ -name 'd_T1_*'
+ files='DATA/P001562/deoblique/d_T1_P001562.nii
DATA/P001562/deoblique/d_T1_P001562.log'
+ for f in '$files'
+ mv DATA/P001562/deoblique/d_T1_P001562.nii DATA/P001562/deoblique/
+ for f in '$files'
+ mv DATA/P001562/deoblique/d_T1_P001562.log DATA/P001562/deoblique/
+ toT1
+ outt1[$i]=d_T1_P001562.nii
+ outpatht1[$i]=DATA/P001562/deoblique/
+ prefixt1[$i]=d_T1_
+ for i in '$ID'
+ get.info1 DATA/T000001/T1_T000001.nii
+ local image=DATA/T000001/T1_T000001.nii
3dinfo -space $image
++ 3dinfo -space DATA/T000001/T1_T000001.nii
+ space=ORIG
3dinfo -is_oblique $image
++ 3dinfo -is_oblique DATA/T000001/T1_T000001.nii
+ is_oblique=1
3dinfo -prefix $image
++ 3dinfo -prefix DATA/T000001/T1_T000001.nii
+ afniprefix=T1_T000001.nii
3dinfo -tr $image
++ 3dinfo -tr DATA/T000001/T1_T000001.nii
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode DATA/T000001/T1_T000001.nii
+ smode=NIFTI
3dinfo -orient $image
++ 3dinfo -orient DATA/T000001/T1_T000001.nii
+ orient=ASL
+ '[' 1 -eq 1 ']'
+ prefix[$i]=d_T1_
+ inputs T1_T000001.nii
+ in[$i]=T1_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/
+ outputs d_T1_T000001.nii
+ out[$i]=d_T1_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/deoblique/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/deoblique/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/T1_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/deoblique/d_T1_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/deoblique/d_T1_T000001.nii -ot DATA/T000001/T1_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/ -name 'd_T1_*'
+ files='DATA/T000001/deoblique/d_T1_T000001.log
DATA/T000001/deoblique/d_T1_T000001.nii'
+ for f in '$files'
+ mv DATA/T000001/deoblique/d_T1_T000001.log DATA/T000001/deoblique/
+ for f in '$files'
+ mv DATA/T000001/deoblique/d_T1_T000001.nii DATA/T000001/deoblique/
+ toT1
+ outt1[$i]=d_T1_T000001.nii
+ outpatht1[$i]=DATA/T000001/deoblique/
+ prefixt1[$i]=d_T1_
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo

 # LEMBAR DE PRINTAR OS DADOS DO GRID NO RELATORIO DO CONTROLE DE QUALIDADE

# HOMOGENIZE RS============================================================
printf "\n=========================HOMOGENIZE RS=======================\n\n"
+ printf '\n=========================HOMOGENIZE RS=======================\n\n'

=========================HOMOGENIZE RS=======================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do 
  fromRS
  prefix[$i]=p${prefix[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefix[$i]}$i.nii"
  outpath[$i]=DATA/$i/homogenize/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dZeropad \
    -RL "$gRL" \
    -AP "$gAP" \
    -IS "$gIS" \
    -prefix ${out[$i]} \
    ${in[$i]} &> ${prefix[$i]}$i.log 
  fi; close.node
  log "HOMOGENIZE RS ";
  toRS
done
+ for i in '$ID'
+ fromRS
+ out[$i]=drt_RS_C000917.nii
+ outpath[$i]=DATA/C000917/deoblique/
+ prefix[$i]=drt_RS_
+ prefix[$i]=pdrt_RS_
+ inputs drt_RS_C000917.nii
+ in[$i]=drt_RS_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/deoblique/
+ outputs pdrt_RS_C000917.nii
+ out[$i]=pdrt_RS_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/homogenize/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/homogenize/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/deoblique/drt_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/homogenize/pdrt_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/homogenize/pdrt_RS_C000917.nii -ot DATA/C000917/deoblique/drt_RS_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/deoblique/ -name 'pdrt_RS_*'
+ files=
+ log 'HOMOGENIZE RS '
+ '[' 0 -eq 1 ']'
+ toRS
+ outrs[$i]=pdrt_RS_C000917.nii
+ outpathrs[$i]=DATA/C000917/homogenize/
+ prefixrs[$i]=pdrt_RS_
+ for i in '$ID'
+ fromRS
+ out[$i]=drt_RS_P001543.nii
+ outpath[$i]=DATA/P001543/deoblique/
+ prefix[$i]=drt_RS_
+ prefix[$i]=pdrt_RS_
+ inputs drt_RS_P001543.nii
+ in[$i]=drt_RS_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/deoblique/
+ outputs pdrt_RS_P001543.nii
+ out[$i]=pdrt_RS_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/homogenize/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/homogenize/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/deoblique/drt_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/homogenize/pdrt_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/homogenize/pdrt_RS_P001543.nii -ot DATA/P001543/deoblique/drt_RS_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/deoblique/ -name 'pdrt_RS_*'
+ files=
+ log 'HOMOGENIZE RS '
+ '[' 0 -eq 1 ']'
+ toRS
+ outrs[$i]=pdrt_RS_P001543.nii
+ outpathrs[$i]=DATA/P001543/homogenize/
+ prefixrs[$i]=pdrt_RS_
+ for i in '$ID'
+ fromRS
+ out[$i]=drt_RS_P001562.nii
+ outpath[$i]=DATA/P001562/deoblique/
+ prefix[$i]=drt_RS_
+ prefix[$i]=pdrt_RS_
+ inputs drt_RS_P001562.nii
+ in[$i]=drt_RS_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/deoblique/
+ outputs pdrt_RS_P001562.nii
+ out[$i]=pdrt_RS_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/homogenize/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/homogenize/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/deoblique/drt_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/homogenize/pdrt_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/homogenize/pdrt_RS_P001562.nii -ot DATA/P001562/deoblique/drt_RS_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/deoblique/ -name 'pdrt_RS_*'
+ files=
+ log 'HOMOGENIZE RS '
+ '[' 0 -eq 1 ']'
+ toRS
+ outrs[$i]=pdrt_RS_P001562.nii
+ outpathrs[$i]=DATA/P001562/homogenize/
+ prefixrs[$i]=pdrt_RS_
+ for i in '$ID'
+ fromRS
+ out[$i]=drt_RS_T000001.nii
+ outpath[$i]=DATA/T000001/deoblique/
+ prefix[$i]=drt_RS_
+ prefix[$i]=pdrt_RS_
+ inputs drt_RS_T000001.nii
+ in[$i]=drt_RS_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/deoblique/
+ outputs pdrt_RS_T000001.nii
+ out[$i]=pdrt_RS_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/homogenize/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/homogenize/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/deoblique/drt_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/homogenize/pdrt_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/homogenize/pdrt_RS_T000001.nii -ot DATA/T000001/deoblique/drt_RS_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/deoblique/ -name 'pdrt_RS_*'
+ files=
+ log 'HOMOGENIZE RS '
+ '[' 0 -eq 1 ']'
+ toRS
+ outrs[$i]=pdrt_RS_T000001.nii
+ outpathrs[$i]=DATA/T000001/homogenize/
+ prefixrs[$i]=pdrt_RS_
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo



# REORIENT T1 TO TEMPLATE================================================
printf "\n====================REORIENT T1 TO TEMPLATE===================\n\n"
+ printf '\n====================REORIENT T1 TO TEMPLATE===================\n\n'

====================REORIENT T1 TO TEMPLATE===================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  fromT1
  get.info1 "template/MNI152_1mm_uni+tlrc"
  prefix[$i]=r${prefix[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefix[$i]}$i.nii"
  outpath[$i]=DATA/$i/reorient_template/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dresample \
    -orient "$orient" \
    -prefix ${out[$i]} \
    -inset ${in[$i]} &> ${prefix[$i]}$i.log 
  fi; close.node
  log "REORIENT T1 TO TEMP "
  toT1
done 
+ for i in '$ID'
+ fromT1
+ out[$i]=d_T1_C000917.nii
+ outpath[$i]=DATA/C000917/deoblique/
+ prefix[$i]=d_T1_
+ get.info1 template/MNI152_1mm_uni+tlrc
+ local image=template/MNI152_1mm_uni+tlrc
3dinfo -space $image
++ 3dinfo -space template/MNI152_1mm_uni+tlrc
+ space=MNI
3dinfo -is_oblique $image
++ 3dinfo -is_oblique template/MNI152_1mm_uni+tlrc
+ is_oblique=0
3dinfo -prefix $image
++ 3dinfo -prefix template/MNI152_1mm_uni+tlrc
+ afniprefix='     MNI152_1mm_uni'
3dinfo -tr $image
++ 3dinfo -tr template/MNI152_1mm_uni+tlrc
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode template/MNI152_1mm_uni+tlrc
+ smode=BRIK
3dinfo -orient $image
++ 3dinfo -orient template/MNI152_1mm_uni+tlrc
+ orient=RPI
+ prefix[$i]=rd_T1_
+ inputs d_T1_C000917.nii
+ in[$i]=d_T1_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/deoblique/
+ outputs rd_T1_C000917.nii
+ out[$i]=rd_T1_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/reorient_template/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/reorient_template/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/deoblique/d_T1_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/reorient_template/rd_T1_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/reorient_template/rd_T1_C000917.nii -ot DATA/C000917/deoblique/d_T1_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/deoblique/ -name 'rd_T1_*'
+ files=
+ log 'REORIENT T1 TO TEMP '
+ '[' 0 -eq 1 ']'
+ toT1
+ outt1[$i]=rd_T1_C000917.nii
+ outpatht1[$i]=DATA/C000917/reorient_template/
+ prefixt1[$i]=rd_T1_
+ for i in '$ID'
+ fromT1
+ out[$i]=d_T1_P001543.nii
+ outpath[$i]=DATA/P001543/deoblique/
+ prefix[$i]=d_T1_
+ get.info1 template/MNI152_1mm_uni+tlrc
+ local image=template/MNI152_1mm_uni+tlrc
3dinfo -space $image
++ 3dinfo -space template/MNI152_1mm_uni+tlrc
+ space=MNI
3dinfo -is_oblique $image
++ 3dinfo -is_oblique template/MNI152_1mm_uni+tlrc
+ is_oblique=0
3dinfo -prefix $image
++ 3dinfo -prefix template/MNI152_1mm_uni+tlrc
+ afniprefix='     MNI152_1mm_uni'
3dinfo -tr $image
++ 3dinfo -tr template/MNI152_1mm_uni+tlrc
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode template/MNI152_1mm_uni+tlrc
+ smode=BRIK
3dinfo -orient $image
++ 3dinfo -orient template/MNI152_1mm_uni+tlrc
+ orient=RPI
+ prefix[$i]=rd_T1_
+ inputs d_T1_P001543.nii
+ in[$i]=d_T1_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/deoblique/
+ outputs rd_T1_P001543.nii
+ out[$i]=rd_T1_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/reorient_template/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/reorient_template/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/deoblique/d_T1_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/reorient_template/rd_T1_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/reorient_template/rd_T1_P001543.nii -ot DATA/P001543/deoblique/d_T1_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/deoblique/ -name 'rd_T1_*'
+ files=
+ log 'REORIENT T1 TO TEMP '
+ '[' 0 -eq 1 ']'
+ toT1
+ outt1[$i]=rd_T1_P001543.nii
+ outpatht1[$i]=DATA/P001543/reorient_template/
+ prefixt1[$i]=rd_T1_
+ for i in '$ID'
+ fromT1
+ out[$i]=d_T1_P001562.nii
+ outpath[$i]=DATA/P001562/deoblique/
+ prefix[$i]=d_T1_
+ get.info1 template/MNI152_1mm_uni+tlrc
+ local image=template/MNI152_1mm_uni+tlrc
3dinfo -space $image
++ 3dinfo -space template/MNI152_1mm_uni+tlrc
+ space=MNI
3dinfo -is_oblique $image
++ 3dinfo -is_oblique template/MNI152_1mm_uni+tlrc
+ is_oblique=0
3dinfo -prefix $image
++ 3dinfo -prefix template/MNI152_1mm_uni+tlrc
+ afniprefix='     MNI152_1mm_uni'
3dinfo -tr $image
++ 3dinfo -tr template/MNI152_1mm_uni+tlrc
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode template/MNI152_1mm_uni+tlrc
+ smode=BRIK
3dinfo -orient $image
++ 3dinfo -orient template/MNI152_1mm_uni+tlrc
+ orient=RPI
+ prefix[$i]=rd_T1_
+ inputs d_T1_P001562.nii
+ in[$i]=d_T1_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/deoblique/
+ outputs rd_T1_P001562.nii
+ out[$i]=rd_T1_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/reorient_template/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/reorient_template/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/deoblique/d_T1_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/reorient_template/rd_T1_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/reorient_template/rd_T1_P001562.nii -ot DATA/P001562/deoblique/d_T1_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/deoblique/ -name 'rd_T1_*'
+ files=
+ log 'REORIENT T1 TO TEMP '
+ '[' 0 -eq 1 ']'
+ toT1
+ outt1[$i]=rd_T1_P001562.nii
+ outpatht1[$i]=DATA/P001562/reorient_template/
+ prefixt1[$i]=rd_T1_
+ for i in '$ID'
+ fromT1
+ out[$i]=d_T1_T000001.nii
+ outpath[$i]=DATA/T000001/deoblique/
+ prefix[$i]=d_T1_
+ get.info1 template/MNI152_1mm_uni+tlrc
+ local image=template/MNI152_1mm_uni+tlrc
3dinfo -space $image
++ 3dinfo -space template/MNI152_1mm_uni+tlrc
+ space=MNI
3dinfo -is_oblique $image
++ 3dinfo -is_oblique template/MNI152_1mm_uni+tlrc
+ is_oblique=0
3dinfo -prefix $image
++ 3dinfo -prefix template/MNI152_1mm_uni+tlrc
+ afniprefix='     MNI152_1mm_uni'
3dinfo -tr $image
++ 3dinfo -tr template/MNI152_1mm_uni+tlrc
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode template/MNI152_1mm_uni+tlrc
+ smode=BRIK
3dinfo -orient $image
++ 3dinfo -orient template/MNI152_1mm_uni+tlrc
+ orient=RPI
+ prefix[$i]=rd_T1_
+ inputs d_T1_T000001.nii
+ in[$i]=d_T1_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/deoblique/
+ outputs rd_T1_T000001.nii
+ out[$i]=rd_T1_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/reorient_template/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/reorient_template/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/deoblique/d_T1_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/reorient_template/rd_T1_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/reorient_template/rd_T1_T000001.nii -ot DATA/T000001/deoblique/d_T1_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/deoblique/ -name 'rd_T1_*'
+ files=
+ log 'REORIENT T1 TO TEMP '
+ '[' 0 -eq 1 ']'
+ toT1
+ outt1[$i]=rd_T1_T000001.nii
+ outpatht1[$i]=DATA/T000001/reorient_template/
+ prefixt1[$i]=rd_T1_
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


# REORIENT RS TO TEMPLATE================================================
printf "\n====================REORIENT RS TO TEMPLATE===================\n\n"
+ printf '\n====================REORIENT RS TO TEMPLATE===================\n\n'

====================REORIENT RS TO TEMPLATE===================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  fromRS
  get.info1 "template/MNI152_1mm_uni+tlrc"
  prefix[$i]=r${prefix[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefix[$i]}$i.nii"
  outpath[$i]=DATA/$i/reorient_template/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dresample \
    -orient "$orient" \
    -prefix ${out[$i]} \
    -inset ${in[$i]} &> ${prefix[$i]}$i.log 
  fi; close.node
  log "REORIENT RS TO TEMP "
  toRS
done 
+ for i in '$ID'
+ fromRS
+ out[$i]=pdrt_RS_C000917.nii
+ outpath[$i]=DATA/C000917/homogenize/
+ prefix[$i]=pdrt_RS_
+ get.info1 template/MNI152_1mm_uni+tlrc
+ local image=template/MNI152_1mm_uni+tlrc
3dinfo -space $image
++ 3dinfo -space template/MNI152_1mm_uni+tlrc
+ space=MNI
3dinfo -is_oblique $image
++ 3dinfo -is_oblique template/MNI152_1mm_uni+tlrc
+ is_oblique=0
3dinfo -prefix $image
++ 3dinfo -prefix template/MNI152_1mm_uni+tlrc
+ afniprefix='     MNI152_1mm_uni'
3dinfo -tr $image
++ 3dinfo -tr template/MNI152_1mm_uni+tlrc
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode template/MNI152_1mm_uni+tlrc
+ smode=BRIK
3dinfo -orient $image
++ 3dinfo -orient template/MNI152_1mm_uni+tlrc
+ orient=RPI
+ prefix[$i]=rpdrt_RS_
+ inputs pdrt_RS_C000917.nii
+ in[$i]=pdrt_RS_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/homogenize/
+ outputs rpdrt_RS_C000917.nii
+ out[$i]=rpdrt_RS_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/reorient_template/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/reorient_template/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/homogenize/pdrt_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/reorient_template/rpdrt_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/reorient_template/rpdrt_RS_C000917.nii -ot DATA/C000917/homogenize/pdrt_RS_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/homogenize/ -name 'rpdrt_RS_*'
+ files=
+ log 'REORIENT RS TO TEMP '
+ '[' 0 -eq 1 ']'
+ toRS
+ outrs[$i]=rpdrt_RS_C000917.nii
+ outpathrs[$i]=DATA/C000917/reorient_template/
+ prefixrs[$i]=rpdrt_RS_
+ for i in '$ID'
+ fromRS
+ out[$i]=pdrt_RS_P001543.nii
+ outpath[$i]=DATA/P001543/homogenize/
+ prefix[$i]=pdrt_RS_
+ get.info1 template/MNI152_1mm_uni+tlrc
+ local image=template/MNI152_1mm_uni+tlrc
3dinfo -space $image
++ 3dinfo -space template/MNI152_1mm_uni+tlrc
+ space=MNI
3dinfo -is_oblique $image
++ 3dinfo -is_oblique template/MNI152_1mm_uni+tlrc
+ is_oblique=0
3dinfo -prefix $image
++ 3dinfo -prefix template/MNI152_1mm_uni+tlrc
+ afniprefix='     MNI152_1mm_uni'
3dinfo -tr $image
++ 3dinfo -tr template/MNI152_1mm_uni+tlrc
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode template/MNI152_1mm_uni+tlrc
+ smode=BRIK
3dinfo -orient $image
++ 3dinfo -orient template/MNI152_1mm_uni+tlrc
+ orient=RPI
+ prefix[$i]=rpdrt_RS_
+ inputs pdrt_RS_P001543.nii
+ in[$i]=pdrt_RS_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/homogenize/
+ outputs rpdrt_RS_P001543.nii
+ out[$i]=rpdrt_RS_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/reorient_template/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/reorient_template/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/homogenize/pdrt_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/reorient_template/rpdrt_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/reorient_template/rpdrt_RS_P001543.nii -ot DATA/P001543/homogenize/pdrt_RS_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/homogenize/ -name 'rpdrt_RS_*'
+ files=
+ log 'REORIENT RS TO TEMP '
+ '[' 0 -eq 1 ']'
+ toRS
+ outrs[$i]=rpdrt_RS_P001543.nii
+ outpathrs[$i]=DATA/P001543/reorient_template/
+ prefixrs[$i]=rpdrt_RS_
+ for i in '$ID'
+ fromRS
+ out[$i]=pdrt_RS_P001562.nii
+ outpath[$i]=DATA/P001562/homogenize/
+ prefix[$i]=pdrt_RS_
+ get.info1 template/MNI152_1mm_uni+tlrc
+ local image=template/MNI152_1mm_uni+tlrc
3dinfo -space $image
++ 3dinfo -space template/MNI152_1mm_uni+tlrc
+ space=MNI
3dinfo -is_oblique $image
++ 3dinfo -is_oblique template/MNI152_1mm_uni+tlrc
+ is_oblique=0
3dinfo -prefix $image
++ 3dinfo -prefix template/MNI152_1mm_uni+tlrc
+ afniprefix='     MNI152_1mm_uni'
3dinfo -tr $image
++ 3dinfo -tr template/MNI152_1mm_uni+tlrc
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode template/MNI152_1mm_uni+tlrc
+ smode=BRIK
3dinfo -orient $image
++ 3dinfo -orient template/MNI152_1mm_uni+tlrc
+ orient=RPI
+ prefix[$i]=rpdrt_RS_
+ inputs pdrt_RS_P001562.nii
+ in[$i]=pdrt_RS_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/homogenize/
+ outputs rpdrt_RS_P001562.nii
+ out[$i]=rpdrt_RS_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/reorient_template/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/reorient_template/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/homogenize/pdrt_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/reorient_template/rpdrt_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/reorient_template/rpdrt_RS_P001562.nii -ot DATA/P001562/homogenize/pdrt_RS_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/homogenize/ -name 'rpdrt_RS_*'
+ files=
+ log 'REORIENT RS TO TEMP '
+ '[' 0 -eq 1 ']'
+ toRS
+ outrs[$i]=rpdrt_RS_P001562.nii
+ outpathrs[$i]=DATA/P001562/reorient_template/
+ prefixrs[$i]=rpdrt_RS_
+ for i in '$ID'
+ fromRS
+ out[$i]=pdrt_RS_T000001.nii
+ outpath[$i]=DATA/T000001/homogenize/
+ prefix[$i]=pdrt_RS_
+ get.info1 template/MNI152_1mm_uni+tlrc
+ local image=template/MNI152_1mm_uni+tlrc
3dinfo -space $image
++ 3dinfo -space template/MNI152_1mm_uni+tlrc
+ space=MNI
3dinfo -is_oblique $image
++ 3dinfo -is_oblique template/MNI152_1mm_uni+tlrc
+ is_oblique=0
3dinfo -prefix $image
++ 3dinfo -prefix template/MNI152_1mm_uni+tlrc
+ afniprefix='     MNI152_1mm_uni'
3dinfo -tr $image
++ 3dinfo -tr template/MNI152_1mm_uni+tlrc
+ tr=0.000000
3dinfo -smode $image
++ 3dinfo -smode template/MNI152_1mm_uni+tlrc
+ smode=BRIK
3dinfo -orient $image
++ 3dinfo -orient template/MNI152_1mm_uni+tlrc
+ orient=RPI
+ prefix[$i]=rpdrt_RS_
+ inputs pdrt_RS_T000001.nii
+ in[$i]=pdrt_RS_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/homogenize/
+ outputs rpdrt_RS_T000001.nii
+ out[$i]=rpdrt_RS_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/reorient_template/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/reorient_template/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/homogenize/pdrt_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/reorient_template/rpdrt_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/reorient_template/rpdrt_RS_T000001.nii -ot DATA/T000001/homogenize/pdrt_RS_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/homogenize/ -name 'rpdrt_RS_*'
+ files=
+ log 'REORIENT RS TO TEMP '
+ '[' 0 -eq 1 ']'
+ toRS
+ outrs[$i]=rpdrt_RS_T000001.nii
+ outpathrs[$i]=DATA/T000001/reorient_template/
+ prefixrs[$i]=rpdrt_RS_
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo



# Align center T1 TO TEMPLATE================================================
printf "\n====================Align center T1 TO TEMPLATE===================\n\n"
+ printf '\n====================Align center T1 TO TEMPLATE===================\n\n'

====================Align center T1 TO TEMPLATE===================

pwd=($PWD)
+ pwd=($PWD)
for i in $ID; do
  fromT1
  prefix[$i]=a${prefix[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefix[$i]}$i.nii"
  outpath[$i]=DATA/$i/align_center/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    @Align_Centers \
    -base "$template" \
    -dset ${in[$i]} &> ${prefix[$i]}$i.log 
    mv rd_T1_"$i"_shft.nii ${prefix[$i]}$i.nii &>> ${prefix[$i]}$i.log 
    mv rd_T1_"$i"_shft.1D ${prefix[$i]}$i.1D &>> ${prefix[$i]}$i.log 
  fi; close.node
  log "Align center T1 TO TEMP "
done 
+ for i in '$ID'
+ fromT1
+ out[$i]=rd_T1_C000917.nii
+ outpath[$i]=DATA/C000917/reorient_template/
+ prefix[$i]=rd_T1_
+ prefix[$i]=ard_T1_
+ inputs rd_T1_C000917.nii
+ in[$i]=rd_T1_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/reorient_template/
+ outputs ard_T1_C000917.nii
+ out[$i]=ard_T1_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/align_center/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/align_center/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/reorient_template/rd_T1_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/align_center/ard_T1_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/align_center/ard_T1_C000917.nii -ot DATA/C000917/reorient_template/rd_T1_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/reorient_template/ -name 'ard_T1_*'
+ files=
+ log 'Align center T1 TO TEMP '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ fromT1
+ out[$i]=rd_T1_P001543.nii
+ outpath[$i]=DATA/P001543/reorient_template/
+ prefix[$i]=rd_T1_
+ prefix[$i]=ard_T1_
+ inputs rd_T1_P001543.nii
+ in[$i]=rd_T1_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/reorient_template/
+ outputs ard_T1_P001543.nii
+ out[$i]=ard_T1_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/align_center/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/align_center/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/reorient_template/rd_T1_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/align_center/ard_T1_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/align_center/ard_T1_P001543.nii -ot DATA/P001543/reorient_template/rd_T1_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/reorient_template/ -name 'ard_T1_*'
+ files=
+ log 'Align center T1 TO TEMP '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ fromT1
+ out[$i]=rd_T1_P001562.nii
+ outpath[$i]=DATA/P001562/reorient_template/
+ prefix[$i]=rd_T1_
+ prefix[$i]=ard_T1_
+ inputs rd_T1_P001562.nii
+ in[$i]=rd_T1_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/reorient_template/
+ outputs ard_T1_P001562.nii
+ out[$i]=ard_T1_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/align_center/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/align_center/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/reorient_template/rd_T1_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/align_center/ard_T1_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/align_center/ard_T1_P001562.nii -ot DATA/P001562/reorient_template/rd_T1_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/reorient_template/ -name 'ard_T1_*'
+ files=
+ log 'Align center T1 TO TEMP '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ fromT1
+ out[$i]=rd_T1_T000001.nii
+ outpath[$i]=DATA/T000001/reorient_template/
+ prefix[$i]=rd_T1_
+ prefix[$i]=ard_T1_
+ inputs rd_T1_T000001.nii
+ in[$i]=rd_T1_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/reorient_template/
+ outputs ard_T1_T000001.nii
+ out[$i]=ard_T1_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/align_center/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/align_center/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/reorient_template/rd_T1_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/align_center/ard_T1_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/align_center/ard_T1_T000001.nii -ot DATA/T000001/reorient_template/rd_T1_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/reorient_template/ -name 'ard_T1_*'
+ files=
+ log 'Align center T1 TO TEMP '
+ '[' 0 -eq 1 ']'
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


# Unifaze T1 ===========================================================
printf "\n=========================Unifaze T1========================\n\n"
+ printf '\n=========================Unifaze T1========================\n\n'

=========================Unifaze T1========================

for i in $ID; do
  prefix[$i]=u${prefix[$i]}
  inputs "${out[$i]}"
  inpath[$i]=${outpath[$i]}
  outputs "${prefix[$i]}$i.nii"
  outpath[$i]=DATA/$i/unifaze/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dUnifize \
    -prefix ${out[$i]} \
    -input ${in[$i]} &> ${prefix[$i]}$i.log
  fi; close.node
  log "Unifaze T1 "
done 
+ for i in '$ID'
+ prefix[$i]=uard_T1_
+ inputs ard_T1_C000917.nii
+ in[$i]=ard_T1_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/align_center/
+ outputs uard_T1_C000917.nii
+ out[$i]=uard_T1_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/C000917/unifaze/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/unifaze/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/align_center/ard_T1_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/unifaze/uard_T1_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/unifaze/uard_T1_C000917.nii -ot DATA/C000917/align_center/ard_T1_C000917.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/align_center/ -name 'uard_T1_*'
+ files=
+ log 'Unifaze T1 '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=uard_T1_
+ inputs ard_T1_P001543.nii
+ in[$i]=ard_T1_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/align_center/
+ outputs uard_T1_P001543.nii
+ out[$i]=uard_T1_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001543/unifaze/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/unifaze/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/align_center/ard_T1_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/unifaze/uard_T1_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/unifaze/uard_T1_P001543.nii -ot DATA/P001543/align_center/ard_T1_P001543.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/align_center/ -name 'uard_T1_*'
+ files=
+ log 'Unifaze T1 '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=uard_T1_
+ inputs ard_T1_P001562.nii
+ in[$i]=ard_T1_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/align_center/
+ outputs uard_T1_P001562.nii
+ out[$i]=uard_T1_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/P001562/unifaze/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/unifaze/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/align_center/ard_T1_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/unifaze/uard_T1_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/unifaze/uard_T1_P001562.nii -ot DATA/P001562/align_center/ard_T1_P001562.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/align_center/ -name 'uard_T1_*'
+ files=
+ log 'Unifaze T1 '
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ prefix[$i]=uard_T1_
+ inputs ard_T1_T000001.nii
+ in[$i]=ard_T1_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/align_center/
+ outputs uard_T1_T000001.nii
+ out[$i]=uard_T1_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=DATA/T000001/unifaze/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/unifaze/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/align_center/ard_T1_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/unifaze/uard_T1_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/unifaze/uard_T1_T000001.nii -ot DATA/T000001/align_center/ard_T1_T000001.nii ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/align_center/ -name 'uard_T1_*'
+ files=
+ log 'Unifaze T1 '
+ '[' 0 -eq 1 ']'
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


## =============================================================================
## ====================== SKULLSTRIP MANUAL=====================================
## =============================================================================

if [ $bet -eq 0 ]; then
  echo "O SKULL STRIP DEVE SER FEITO MANUALMENTE. USE COMO BASE O ARQUIVO QUE ESTÁ NA PASTA DATA/manual_skullstrip. NOMEIE O ARQUIVO mask_T1_<SUBID>.nii.gz e salve no diretório base." | fold -s
  for i in $ID; do
    [ ! -d "$pwd/OUTPUT/$i/manual_skullstrip" ] && mkdir -p $pwd/OUTPUT/$i/manual_skullstrip 
    [ ! -d "$pwd/DATA/$i/skullstrip" ] && mkdir -p $pwd/DATA/$i/skullstrip
    cp ${outpath[$i]}${out[$i]} OUTPUT/$i/manual_skullstrip 2> /dev/null
    ss=$(find . -name "mask_T1_$i*")
    mv $ss /DATA/$i/skullstrip 2> /dev/null
  done
  else

echo "#!/usr/bin/env bash" >> optiBET.sh
echo "fslpath=$fslpath" >> optiBET.sh
cat > optiBET.sh << 'EOF'

################## 2/6/14 #########################
# Script by Evan Lutkenhoff, lutkenhoff@ucla.edu  #
# Monti Lab (http://montilab.psych.ucla.edu)      #
# Tools used within script are copyrighted by:    #   
# FSL (http://fsl.fmrib.ox.ac.uk/fsl/fslwiki/FSL) #
# & AFNI (http://afni.nimh.nih.gov/afni/)         #
###################################################

FSLDIR=${fslpath##/*/}
####usage notes/comments####
howtouse() {
echo ""
echo "How To Use:   sh optiBET.sh -i <input_image> -options"
echo ""
echo "* if option is -f script uses FSL for initial extraction (default)"
echo "* if option is -a script uses AFNI for initial extraction"
echo "* if option is -o script uses MNI152_T1_1mm_brain_mask.nii.gz for mask (default)"
echo "* if option is -t script uses MNI152_T1_2mm_brain_mask.nii.gz for mask"
echo "* if option is -g script uses avg152T1_brain.nii.gz for mask"
echo "* if option is -d use debug mode (will NOT delete intermediate files)"
echo "* script requires proper installation of FSL and AFNI"
echo "* input image should be in standard orientation"
echo "* use .nii.gz image for input"
echo "* outputs binarized brain-extraction mask, saved as:  <input_image>_optiBET_brain_mask.nii.gz"
echo "* and full-intensity brain-extraction, saved as: <input_image>_optiBET_brain.nii.gz"
echo ""
exit 1
}
[ "$1" = "" ] && howtouse

####setup environment variables####
#setup environment variable for AFNI
afnidirtemp=/usr/lib/afni/bin/3dSkullStrip
afnidir=
#setup environment variables for FSL
#FSLDIR already stored if installed


####PARSE options########################
#sets up initial values for brain extraction and MNI mask and debug
s1=bet; #default step1
mask=MNI152_T1_1mm_brain_mask.nii.gz; #default MNI mask
debugger=no; #default delete intermediate files

while getopts i:faotgd name
do
case $name in
i)iopt=$OPTARG;;
f)fopt=1;;
a)aopt=1;;
o)oopt=1;;
t)topt=1;;
g)gopt=1;;
d)dopt=1;;
*)echo "Invalid option as argument"; exit 1;; #exits if bad option used
esac
done

if [[ ! -z $iopt ]]
then
i=; #removes file extensions from input image
echo $i "is input image"
fi
if [[ ! -z $fopt ]]
then
s1=bet; #use FSL
fi
if [[ ! -z $aopt ]]
then
s1=3dSS; #use AFNI
fi
if [[ ! -z $oopt ]]
then
mask=MNI152_T1_1mm_brain_mask.nii.gz; #use 1mm mask
fi
if [[ ! -z $topt ]]
then
mask=MNI152_T1_2mm_brain_mask.nii.gz; #use 2mm mask
fi
if [[ ! -z $gopt ]]
then
mask=avg152T1_brain.nii.gz; #use avg mask
fi
if [[ ! -z $dopt ]]
then
debugger=yes; #keeps intermediate files
echo "debug: do NOT delete intermediate files"
fi
#following takes care of inputting conflicting options
if [[ ! -z $fopt ]] && [[ ! -z $aopt ]]; then
echo "only specify one option for inital extraction (-f OR -a)"
exit 1
fi
if [[ ! -z $oopt ]] && [[ ! -z $topt ]] && [[ ! -z $gopt ]]; then
echo "only specify one option for mask (-o, -t, or -g)"
exit 1
fi
if [[ ! -z $oopt ]] && [[ ! -z $topt ]]; then
echo "only specify one option for mask (-o, -t, or -g)"
exit 1
fi
if [[ ! -z $oopt ]] && [[ ! -z $gopt ]]; then
echo "only specify one option for mask (-o, -t, or -g)"
exit 1
fi
if [[ ! -z $topt ]] && [[ ! -z $gopt ]]; then
echo "only specify one option for mask (-o, -t, or -g)"
exit 1
fi

shift $(($OPTIND -1))
echo "for subject $iopt use $s1 for step 1 and $mask for MNI mask"
####END PARSE #################################


#### 1. initial brain extraction (“step 1”) #########################
## Perform initial “approximate” brain extraction (use FSL unless input options specify the AFNI option)
# this is referred to as “step 1” in the manuscript.

if [[ "$s1" == "bet" ]]; then
    echo step1 BET -B -f 0.1 subject ${i} for initial extraction
    "$fslpath"bet ${iopt} ${i}_step1 -B -f 0.25
else
    echo step1 AFNI 3dSkullStrip subject ${i} for initial extraction
$afnidir/3dSkullStrip -input ${iopt} -prefix ${i}_step1.nii.gz &>/dev/null #suppress screen output b/c a lot
fi

#### 2. linear transform to MNI space (“step 2”) ####################
## Perform linear transformation of initial “approximate” extraction to MNI space
# This is referred to as “step 2” in the manuscript.

echo step2 flirt subject ${i} to MNI space
"$fslpath"flirt -ref ${FSLDIR}/data/standard/MNI152_T1_2mm_brain -in ${i}_step1.nii.gz -omat ${i}_step2.mat -out ${i}_step2 -searchrx -30 30 -searchry -30 30 -searchrz -30 30

#### 3. nonlinear transform to MNI space (“step 3”) ##################
## Follow the linear transformation with a non-linear transformation.  Use the MNI152 2mm as default
# This is referred to as “step 3” in the manuscript

echo step3 fnirt subject ${i} to MNI space
"$fslpath"fnirt --in=${i} --aff=${i}_step2.mat --cout=${i}_step3 --config=T1_2_MNI152_2mm

#### 4. QC: Generate image for QC of fnirt ####################################
## This is a quality control step that generates an image of the original subject structural after transformation to MNI space
# which can (and should) be checked by the user.

echo step4 quality control of fnirt using applywarp to put subject ${i} in MNI space
"$fslpath"applywarp --ref=${FSLDIR}/data/standard/MNI152_T1_2mm --in=${i} --warp=${i}_step3 --out=${i}_step4

#### 5. Invert nonlinear warp (“step 4a”) ############################
## Invert the nonlinear warp in order to be able to back-project the MNI brain into subject space
# this is the first part of “step 4” in the manuscript

echo step5 invert nonlinear warp for subject ${i}
"$fslpath"invwarp -w ${i}_step3.nii.gz -o ${i}_step5.nii.gz -r ${i}_step1.nii.gz

#### 6. Apply inverted nonlinear warp to labels (“step 4b”) ##########
## Apply inverted nonlinear warp to the MNI standard brain in order to back-project it back into subject space
# this is the second part of “step 4” in the manuscript

echo step6 apply inverted nonlinear warp to MNI label: MNI152_T1_1mm_brain_mask for subject ${i}
"$fslpath"applywarp --ref=${i} --in=${FSLDIR}/data/standard/${mask} --warp=${i}_step5.nii.gz --out=${i}_step6 --interp=nn

#### 7. binarize brain extractions ###################################
## Binarize the back-projected MNI brain in order to use it to “punch-out” brain extraction (in the next step)

echo step 7 creating binary brain mask for subject ${i}
"$fslpath"fslmaths ${i}_step6.nii.gz -bin ${i}_optiBET_brain_mask

#### 8. Punch-out mask from brain to do skull-stripping (“step 4c”) ##
## Take the binarized back-projected MNI brain and use it to “punch-out" non-brain tissue from the subject’s original T1 image
# this is the last part of “step 4” as described in the manuscript).

echo step 8 creating brain extraction for subject ${i}
"$fslpath"fslmaths ${i} -mas ${i}_optiBET_brain_mask ${i}_optiBET_brain

###debug or not #####
if [ "$debugger" == "yes" ];then
echo "keep intermediate files"
else
echo "removing intermediate files"
rm ${i}_step1.nii.gz ${i}_step1_mask.nii.gz ${i}_step2.nii.gz ${i}_step2.mat ${i}_step3.nii.gz ${i}_step4.nii.gz ${i}_step5.nii.gz ${i}_step6.nii.gz ${i}_to_MNI152_T1_2mm.log
fi
EOF
chmod +x optiBET.sh

  # BET ============================================================
  printf "\n============================BET============================\n\n"
  pwd=($PWD)
  for i in $ID; do
    prefix[$i]=SS_T1_
    inputs "${out[$i]}"
    inpath[$i]=${outpath[$i]}
    outputs "${prefix[$i]}$i.nii"
    outpath[$i]=/DATA/$i/skullstrip/
    echo -n "$i> "
    open.node; if [ $go -eq 1 ]; then
      $pwd/optiBET.sh ${in[$i]} #&> ${prefix[$i]}$i.log
      mv optiBET* ${outpath[$i]} 2> /dev/null
    fi; close.node
    log "BET "
  done 
  input.error
  echo
fi
+ '[' 1 -eq 0 ']'
+ echo '#!/usr/bin/env bash'
+ echo fslpath=/usr/share/fsl/5.0/bin/
+ cat
+ chmod +x optiBET.sh
+ printf '\n============================BET============================\n\n'

============================BET============================

+ pwd=($PWD)
+ for i in '$ID'
+ prefix[$i]=SS_T1_
+ inputs uard_T1_C000917.nii
+ in[$i]=uard_T1_C000917.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/C000917/unifaze/
+ outputs SS_T1_C000917.nii
+ out[$i]=SS_T1_C000917.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=/DATA/C000917/skullstrip/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d /DATA/C000917/skullstrip/ ']'
+ mkdir /DATA/C000917/skullstrip/
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/unifaze/uard_T1_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f /DATA/C000917/skullstrip/SS_T1_C000917.nii ']'
+ b=1
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/C000917/unifaze/
+ '[' 1 -eq 1 ']'
+ /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh uard_T1_C000917.nii
for subject  use bet for step 1 and MNI152_T1_1mm_brain_mask.nii.gz for MNI mask
step1 BET -B -f 0.1 subject for initial extraction
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 123: bet: command not found
step2 flirt subject to MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 134: flirt: command not found
step3 fnirt subject to MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 141: fnirt: command not found
step4 quality control of fnirt using applywarp to put subject in MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 148: applywarp: command not found
step5 invert nonlinear warp for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 155: invwarp: command not found
step6 apply inverted nonlinear warp to MNI label: MNI152_T1_1mm_brain_mask for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 162: applywarp: command not found
step 7 creating binary brain mask for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 168: fslmaths: command not found
step 8 creating brain extraction for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 175: fslmaths: command not found
removing intermediate files
rm: cannot remove ‘_step1.nii.gz’: No such file or directory
rm: cannot remove ‘_step1_mask.nii.gz’: No such file or directory
rm: cannot remove ‘_step2.nii.gz’: No such file or directory
rm: cannot remove ‘_step2.mat’: No such file or directory
rm: cannot remove ‘_step3.nii.gz’: No such file or directory
rm: cannot remove ‘_step4.nii.gz’: No such file or directory
rm: cannot remove ‘_step5.nii.gz’: No such file or directory
rm: cannot remove ‘_step6.nii.gz’: No such file or directory
rm: cannot remove ‘_to_MNI152_T1_2mm.log’: No such file or directory
+ mv 'optiBET*' /DATA/C000917/skullstrip/
+ close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/C000917/unifaze/SS_T1_C000917.log /DATA/C000917/skullstrip/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f /DATA/C000917/skullstrip/SS_T1_C000917.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ printf 'Houve um erro no processamento da imagem %s, consulte o log. \n' C000917
Houve um erro no processamento da imagem C000917, consulte o log. 
+ ex=1
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/C000917/unifaze/ -name 'SS_T1_*'
+ files=DATA/C000917/unifaze/SS_T1_C000917.log
+ for f in '$files'
+ mv DATA/C000917/unifaze/SS_T1_C000917.log /DATA/C000917/skullstrip/
+ log 'BET '
+ '[' 1 -eq 1 ']'
+ echo
date
++ date
+ echo 'ETAPA: BET   - RUNTIME: Tue Dec 13 14:39:44 BRST 2016'
+ echo
+ echo 'PREFIX: SS_T1_'
+ echo 'INPUT PATH: DATA/C000917/unifaze/ '
+ echo 'INPUTS: uard_T1_C000917.nii   '
+ echo 'OUTPUT PATH: /DATA/C000917/skullstrip/'
+ echo 'OUTPUTS: SS_T1_C000917.nii   '
+ echo
+ cat /DATA/C000917/skullstrip/SS_T1_C000917.log
+ for i in '$ID'
+ prefix[$i]=SS_T1_
+ inputs uard_T1_P001543.nii
+ in[$i]=uard_T1_P001543.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001543/unifaze/
+ outputs SS_T1_P001543.nii
+ out[$i]=SS_T1_P001543.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=/DATA/P001543/skullstrip/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d /DATA/P001543/skullstrip/ ']'
+ mkdir /DATA/P001543/skullstrip/
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/unifaze/uard_T1_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f /DATA/P001543/skullstrip/SS_T1_P001543.nii ']'
+ b=1
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/P001543/unifaze/
+ '[' 1 -eq 1 ']'
+ /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh uard_T1_P001543.nii
for subject  use bet for step 1 and MNI152_T1_1mm_brain_mask.nii.gz for MNI mask
step1 BET -B -f 0.1 subject for initial extraction
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 123: bet: command not found
step2 flirt subject to MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 134: flirt: command not found
step3 fnirt subject to MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 141: fnirt: command not found
step4 quality control of fnirt using applywarp to put subject in MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 148: applywarp: command not found
step5 invert nonlinear warp for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 155: invwarp: command not found
step6 apply inverted nonlinear warp to MNI label: MNI152_T1_1mm_brain_mask for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 162: applywarp: command not found
step 7 creating binary brain mask for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 168: fslmaths: command not found
step 8 creating brain extraction for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 175: fslmaths: command not found
removing intermediate files
rm: cannot remove ‘_step1.nii.gz’: No such file or directory
rm: cannot remove ‘_step1_mask.nii.gz’: No such file or directory
rm: cannot remove ‘_step2.nii.gz’: No such file or directory
rm: cannot remove ‘_step2.mat’: No such file or directory
rm: cannot remove ‘_step3.nii.gz’: No such file or directory
rm: cannot remove ‘_step4.nii.gz’: No such file or directory
rm: cannot remove ‘_step5.nii.gz’: No such file or directory
rm: cannot remove ‘_step6.nii.gz’: No such file or directory
rm: cannot remove ‘_to_MNI152_T1_2mm.log’: No such file or directory
+ mv 'optiBET*' /DATA/P001543/skullstrip/
+ close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/P001543/unifaze/SS_T1_P001543.log /DATA/P001543/skullstrip/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f /DATA/P001543/skullstrip/SS_T1_P001543.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ printf 'Houve um erro no processamento da imagem %s, consulte o log. \n' P001543
Houve um erro no processamento da imagem P001543, consulte o log. 
+ ex=1
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001543/unifaze/ -name 'SS_T1_*'
+ files=DATA/P001543/unifaze/SS_T1_P001543.log
+ for f in '$files'
+ mv DATA/P001543/unifaze/SS_T1_P001543.log /DATA/P001543/skullstrip/
+ log 'BET '
+ '[' 1 -eq 1 ']'
+ echo
date
++ date
+ echo 'ETAPA: BET   - RUNTIME: Tue Dec 13 14:39:44 BRST 2016'
+ echo
+ echo 'PREFIX: SS_T1_'
+ echo 'INPUT PATH: DATA/P001543/unifaze/ '
+ echo 'INPUTS: uard_T1_P001543.nii   '
+ echo 'OUTPUT PATH: /DATA/P001543/skullstrip/'
+ echo 'OUTPUTS: SS_T1_P001543.nii   '
+ echo
+ cat /DATA/P001543/skullstrip/SS_T1_P001543.log
+ for i in '$ID'
+ prefix[$i]=SS_T1_
+ inputs uard_T1_P001562.nii
+ in[$i]=uard_T1_P001562.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/P001562/unifaze/
+ outputs SS_T1_P001562.nii
+ out[$i]=SS_T1_P001562.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=/DATA/P001562/skullstrip/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d /DATA/P001562/skullstrip/ ']'
+ mkdir /DATA/P001562/skullstrip/
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/unifaze/uard_T1_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f /DATA/P001562/skullstrip/SS_T1_P001562.nii ']'
+ b=1
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/P001562/unifaze/
+ '[' 1 -eq 1 ']'
+ /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh uard_T1_P001562.nii
for subject  use bet for step 1 and MNI152_T1_1mm_brain_mask.nii.gz for MNI mask
step1 BET -B -f 0.1 subject for initial extraction
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 123: bet: command not found
step2 flirt subject to MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 134: flirt: command not found
step3 fnirt subject to MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 141: fnirt: command not found
step4 quality control of fnirt using applywarp to put subject in MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 148: applywarp: command not found
step5 invert nonlinear warp for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 155: invwarp: command not found
step6 apply inverted nonlinear warp to MNI label: MNI152_T1_1mm_brain_mask for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 162: applywarp: command not found
step 7 creating binary brain mask for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 168: fslmaths: command not found
step 8 creating brain extraction for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 175: fslmaths: command not found
removing intermediate files
rm: cannot remove ‘_step1.nii.gz’: No such file or directory
rm: cannot remove ‘_step1_mask.nii.gz’: No such file or directory
rm: cannot remove ‘_step2.nii.gz’: No such file or directory
rm: cannot remove ‘_step2.mat’: No such file or directory
rm: cannot remove ‘_step3.nii.gz’: No such file or directory
rm: cannot remove ‘_step4.nii.gz’: No such file or directory
rm: cannot remove ‘_step5.nii.gz’: No such file or directory
rm: cannot remove ‘_step6.nii.gz’: No such file or directory
rm: cannot remove ‘_to_MNI152_T1_2mm.log’: No such file or directory
+ mv 'optiBET*' /DATA/P001562/skullstrip/
+ close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/P001562/unifaze/SS_T1_P001562.log /DATA/P001562/skullstrip/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f /DATA/P001562/skullstrip/SS_T1_P001562.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ printf 'Houve um erro no processamento da imagem %s, consulte o log. \n' P001562
Houve um erro no processamento da imagem P001562, consulte o log. 
+ ex=1
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/P001562/unifaze/ -name 'SS_T1_*'
+ files=DATA/P001562/unifaze/SS_T1_P001562.log
+ for f in '$files'
+ mv DATA/P001562/unifaze/SS_T1_P001562.log /DATA/P001562/skullstrip/
+ log 'BET '
+ '[' 1 -eq 1 ']'
+ echo
date
++ date
+ echo 'ETAPA: BET   - RUNTIME: Tue Dec 13 14:39:44 BRST 2016'
+ echo
+ echo 'PREFIX: SS_T1_'
+ echo 'INPUT PATH: DATA/P001562/unifaze/ '
+ echo 'INPUTS: uard_T1_P001562.nii   '
+ echo 'OUTPUT PATH: /DATA/P001562/skullstrip/'
+ echo 'OUTPUTS: SS_T1_P001562.nii   '
+ echo
+ cat /DATA/P001562/skullstrip/SS_T1_P001562.log
+ for i in '$ID'
+ prefix[$i]=SS_T1_
+ inputs uard_T1_T000001.nii
+ in[$i]=uard_T1_T000001.nii
+ in_2[$i]=
+ in_3[$i]=
+ in_4[$i]=
+ inpath[$i]=DATA/T000001/unifaze/
+ outputs SS_T1_T000001.nii
+ out[$i]=SS_T1_T000001.nii
+ out_2[$i]=
+ out_3[$i]=
+ out_4[$i]=
+ outpath[$i]=/DATA/T000001/skullstrip/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d /DATA/T000001/skullstrip/ ']'
+ mkdir /DATA/T000001/skullstrip/
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/unifaze/uard_T1_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f /DATA/T000001/skullstrip/SS_T1_T000001.nii ']'
+ b=1
+ '[' '!' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ '[' 1 -eq 1 ']'
+ cd DATA/T000001/unifaze/
+ '[' 1 -eq 1 ']'
+ /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh uard_T1_T000001.nii
for subject  use bet for step 1 and MNI152_T1_1mm_brain_mask.nii.gz for MNI mask
step1 BET -B -f 0.1 subject for initial extraction
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 123: bet: command not found
step2 flirt subject to MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 134: flirt: command not found
step3 fnirt subject to MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 141: fnirt: command not found
step4 quality control of fnirt using applywarp to put subject in MNI space
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 148: applywarp: command not found
step5 invert nonlinear warp for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 155: invwarp: command not found
step6 apply inverted nonlinear warp to MNI label: MNI152_T1_1mm_brain_mask for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 162: applywarp: command not found
step 7 creating binary brain mask for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 168: fslmaths: command not found
step 8 creating brain extraction for subject
/home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING/optiBET.sh: line 175: fslmaths: command not found
removing intermediate files
rm: cannot remove ‘_step1.nii.gz’: No such file or directory
rm: cannot remove ‘_step1_mask.nii.gz’: No such file or directory
rm: cannot remove ‘_step2.nii.gz’: No such file or directory
rm: cannot remove ‘_step2.mat’: No such file or directory
rm: cannot remove ‘_step3.nii.gz’: No such file or directory
rm: cannot remove ‘_step4.nii.gz’: No such file or directory
rm: cannot remove ‘_step5.nii.gz’: No such file or directory
rm: cannot remove ‘_step6.nii.gz’: No such file or directory
rm: cannot remove ‘_to_MNI152_T1_2mm.log’: No such file or directory
+ mv 'optiBET*' /DATA/T000001/skullstrip/
+ close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv DATA/T000001/unifaze/SS_T1_T000001.log /DATA/T000001/skullstrip/
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f /DATA/T000001/skullstrip/SS_T1_T000001.nii ']'
+ e=1
+ '[' '!' 1 -eq 0 ']'
+ printf 'Houve um erro no processamento da imagem %s, consulte o log. \n' T000001
Houve um erro no processamento da imagem T000001, consulte o log. 
+ ex=1
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
 find "${inpath[$i]}" -name "${prefix[$i]}*" 
++ find DATA/T000001/unifaze/ -name 'SS_T1_*'
+ files=DATA/T000001/unifaze/SS_T1_T000001.log
+ for f in '$files'
+ mv DATA/T000001/unifaze/SS_T1_T000001.log /DATA/T000001/skullstrip/
+ log 'BET '
+ '[' 1 -eq 1 ']'
+ echo
date
++ date
+ echo 'ETAPA: BET   - RUNTIME: Tue Dec 13 14:39:44 BRST 2016'
+ echo
+ echo 'PREFIX: SS_T1_'
+ echo 'INPUT PATH: DATA/T000001/unifaze/ '
+ echo 'INPUTS: uard_T1_T000001.nii   '
+ echo 'OUTPUT PATH: /DATA/T000001/skullstrip/'
+ echo 'OUTPUTS: SS_T1_T000001.nii   '
+ echo
+ cat /DATA/T000001/skullstrip/SS_T1_T000001.log
+ input.error
+ '[' 1 -eq 1 ']'
+ exit
