#!/usr/bin/env bash

# PROCESSANDO OS ARGUMENTOS ====================================================
usage() {
    echo "Argumentos:"
    echo " $0 [ --var <txt com variáveis para análise> | --subs <ID das imagens> ]"
    echo " $0 [ -h | --help ]"
    echo
}

aztec=0
+ aztec=0


i=$(($# + 1)) # index of the first non-existing argument
+ i=5
declare -A longoptspec
+ declare -A longoptspec
longoptspec=( [config]=1 [subs]=1 )
+ longoptspec=([config]=1 [subs]=1)
optspec=":l:h:a-:"
+ optspec=:l:h:a-:
while getopts "$optspec" opt; do
while true; do
    case "${opt}" in
        -) #OPTARG is name-of-long-option or name-of-long-option=value
            if [[ ${OPTARG} =~ .*=.* ]] # with this --key=value format only one argument is possible
            then
                opt=${OPTARG/=*/}
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                if (($((longoptspec[$opt])) != 1))
                then
                    echo "Syntax error: Option '$opt' does not support this syntax." >&2
                    exit
                fi
                OPTARG=${OPTARG#*=}
            else #with this --key value1 value2 format multiple arguments are possible
                opt="$OPTARG"
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
                ((OPTIND+=longoptspec[$opt]))
                #echo $OPTIND
                ((OPTIND > i)) && {
                    echo "Syntax error: Not all required arguments for option '$opt' are given." >&2
                    exit
                }
            fi

            continue #now that opt/OPTARG are set we can process them as
            # if getopts would've given us long options
            ;;
       a|aztec)
            aztec=1
            ;;
        c|config)
          config=$OPTARG
            ;;
        s|subs)
            subs=$OPTARG
            ;;
        h|help)
            usage
            exit 0
            ;;
        ?)
            echo "Erro de sintaxe:'$OPTARG' desconhecida" >&2
            usage
            exit
            ;;
        *)
            echo "Erro de sintaxe:'$opt' desconhecida'" >&2
            usage
            exit
            ;;
    esac
break; done
done
+ getopts :l:h:a-: opt
+ true
+ case "${opt}" in
+ [[ config =~ .*=.* ]]
+ opt=config
+ (( 6 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[config] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ config=preproc.cfg
+ break
+ getopts :l:h:a-: opt
+ true
+ case "${opt}" in
+ [[ subs =~ .*=.* ]]
+ opt=subs
+ (( 4 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[subs] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ subs=preproc.sbj
+ break
+ getopts :l:h:a-: opt

# ==============================================================================

# DECLARANDO FUNÇÕES ===========================================================
check () {
  if command -v $1 > /dev/null; then
    echo "OK"
  else
    echo "Não encontrado em \$PATH"
fi
}

input.error () {
[ $ex -eq ${#ID[@]} ] && exit
}

open.node () {
  [ -d ${outpath[$i]} ] || mkdir ${outpath[$i]}
  #
  local a=0; local b=0; local c=0; local d=0; local v=0
  ex=0; go=1
  #
  for ii in ${in[$i]} ${in_2[$i]} ${in_3[$i]} ${in_4[$i]}; do
      if [ ! -f ${inpath[$i]}$ii ]; then
          echo "INPUT $ii não encontrado"
          a=$((a + 1))            
      else
          for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do
              if [ ! -f ${outpath[$i]}$iii ]; then
                  b=$((b + 1))
                else
                  d=$((d + 1))
                  [ ${outpath[$i]}$iii -ot ${inpath[$i]}$ii ] && echo -n "INPUT $ii MODIFICADO. REFAZENDO ANÁLISE. " && c=$((c + 1))
              fi
          done
      fi
  done
  #
  if [ $a -eq 0 ]; then
  #
    if [ $b -eq 0 ]; then 
      if [ ! $c -eq 0 ]; then
        for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do rm ${outpath[$i]}$iii 2> /dev/null; done
      else
          echo "OUTPUT JÁ EXISTE. PROSSEGUINDO."; go=0; ex=0
      fi
    else
        if [ ! $d -eq 0 ]; then
            echo "OUTPUT CORROMPIDO. REFAZENDO ANÁLISE."
            for ii in ${out[@]}; do rm ${outpath[$i]}$ii 2> /dev/null; done
        fi
    fi
    #
    if [ $go -eq 1 ]; then
      cd ${inpath[$i]}
    fi
  else
  go=0
  fi
  
}

close.node () {
  local e=0
  if [ $go -eq 1 ]; then  
    cd $pwd
    mv ${inpath[$i]}$prefix* ${outpath[$i]}
     for iii in ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}; do 
      [ -f ${outpath[$i]}$iii ] ||  e=$((e + 1)) 
    done
    # 
    [ ! $e -eq 0 ] && echo "OUTPUT CORROMPIDO. CONSULTE O LOG." && ex=$((ex + 1)) 
  fi

 local files=$( find "${inpath[$i]}" -name "$prefix*" )
  for f in $files; do
    mv $f ${outpath[$i]} 2> /dev/null
  done
}

log () {
if [ $go -eq 1 ]; then
  echo >> DATA/preproc_$i.log
  echo "ETAPA: $1  - RUNTIME: $(date)" >> DATA/preproc_$i.log
  echo >> DATA/preproc_$i.log
  echo "PREFIX: $prefix" >> DATA/preproc_$i.log
  echo "INPUT PATH: ${inpath[$i]} "  >> DATA/preproc_$i.log
  echo "INPUTS: ${in[$i]} ${in_2[$i]} ${in_3[$i]} ${in_4[$i]}" >>DATA/preproc_$i.log
  echo "OUTPUT PATH: ${outpath[$i]}" >> DATA/preproc_$i.log
  echo "OUTPUTS: ${out[$i]} ${out_2[$i]} ${out_3[$i]} ${out_4[$i]}" >> DATA/preproc_$i.log
  echo >> DATA/preproc_$i.log
  cat ${outpath[$i]}$prefix$i.log >> DATA/preproc_$i.log
fi
}
# ==============================================================================


# INÍCIO =======================================================================

fold -s <<-EOF

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: $(date)

Programas necessários:
GNU bash           ...$(check bash)
AFNI               ...$(check afni)
FSL                ...$(check fsl5.0-fast)
MATLAB             ...$(check matlab)
  SPM5
  aztec

EOF
+ fold -s
date
++ date
check bash
++ check bash
++ command -v bash
++ echo OK
check afni
++ check afni
++ command -v afni
++ echo OK
check fsl5.0-fast
++ check fsl5.0-fast
++ command -v fsl5.0-fast
++ echo OK
check matlab
++ check matlab
++ command -v matlab
++ echo OK

Protocolo de pré-processamento de RS-fMRI
--------------------------------------

RUNTIME: Thu Dec  8 18:26:04 BRST 2016

Programas necessários:
GNU bash           ...OK
AFNI               ...OK
FSL                ...OK
MATLAB             ...OK
  SPM5
  aztec


if ( ! command -v bash || ! command -v afni || ! command -v fsl5.0-fast  ) > /dev/null ; then
	printf "\nUm ou mais programas necessários para o pré-processamento não estão instalados (acima). Por favor instale o(s) programa(s) faltante(s) ou então verifique se estão configurados na variável de ambiente \$PATH\n\n" | fold -s
	exit
fi
+ command -v bash
+ command -v afni
+ command -v fsl5.0-fast
[ $aztec -eq 1 ] && [ ! $(command -v matlab) ] && echo "o Matlab e os plugins SPM5 e aztec são necessários para a análise e não foram encontrados. Certifique-se que eles estão instalados e configurados na variável de ambiente $PATH" | fold -s && exit 
+ '[' 0 -eq 1 ']'

if [ ! -z $config ]; then  
  if [ -f $config ]; then
    source $config
    a=0
    for var in ptn mcbase gRL gAP gIS orient template blur; do
      if [[ -z "${!var:-}" ]]; then
      echo "Variável $var não encontrada"
      a=$(($a + 1))
      fi
    done
    if [ ! $a -eq 0 ]; then
      echo "Erro: Não é possível executar o script sem as variáveis acima estarem definidas no arquivo de configuração. Encerrando"
      exit
    fi
    unset a
  else
  echo "Arquivo de configuração especificado não encontrado"
  exit
  fi
else 
  echo "O arquivo de configuração não foi especificado"
  if [ ! -f preproc.cfg ]; then
    echo "Será criado um arquivo de configuração com valores padrão: preproc.cfg"
    cat > preproc.cfg << EOL
# Variáveis RS-fMRI Preprocessing:

TR=2000
hp=0
ptn=seq+z
mcbase=100
gRL=90
gAP=90
gIS=60
orient="rpi"
template="MNI152_1mm_uni+tlrc"
blur=6
EOL
exit
  else
    echo "Será usado o arquivo local preproc.cfg"
    source preproc.cfg
  fi
fi  
+ '[' '!' -z preproc.cfg ']'
+ '[' -f preproc.cfg ']'
+ source preproc.cfg
# Variáveis RS-fMRI Preprocessing:

TR=2000
++ TR=2000
hp=0
++ hp=0
ptn=seq+z
++ ptn=seq+z
mcbase=100
++ mcbase=100
gRL=90
++ gRL=90
gAP=90
++ gAP=90
gIS=60
++ gIS=60
orient="rpi"
++ orient=rpi
template="MNI152_1mm_uni+tlrc"
++ template=MNI152_1mm_uni+tlrc
blur=6
++ blur=6
+ a=0
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z seq+z ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 100 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 90 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 90 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 60 ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z rpi ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z MNI152_1mm_uni+tlrc ]]
+ for var in ptn mcbase gRL gAP gIS orient template blur
+ [[ -z 6 ]]
+ '[' '!' 0 -eq 0 ']'
+ unset a


# informando os usuários das variáveis definidas ou defaults
fold -s <<-EOF
As variáveis que serão usadas como parametros para as análises são:
Aztec                   - Tempo de repetição(ms)  => $TR
Slice timing correction - sequência de aquisição  => $ptn
Motion correction       - valor base              => $mcbase
Homogenize Grid         - tamanho da grade        => $gRL $gAP $gIS

EOF
+ fold -s
As variáveis que serão usadas como parametros para as análises são:
Aztec                   - Tempo de repetição(ms)  => 2000
Slice timing correction - sequência de aquisição  => seq+z
Motion correction       - valor base              => 100
Homogenize Grid         - tamanho da grade        => 90 90 60


# Checando arquivo com nome dos indivíduos
if [ ! -z $subs ]; then  
  if [ ! -f $subs ]; then
    echo "Arquivo com ID dos indivíduos especificado não encontrado"
    exit
  fi
else 
  if [ -f preproc.sbj ]; then
    subs=preproc.sbj
  else
    echo "O arquivo com ID dos indivíduos não foi especificado" 
    exit
  fi
fi  
+ '[' '!' -z preproc.sbj ']'
+ '[' '!' -f preproc.sbj ']'

ID=$(cat $subs)
cat $subs
++ cat preproc.sbj
+ ID='C000917
P001543
P001562
T000001'
echo "Lista de indivíduos para análise:"
+ echo 'Lista de indivíduos para análise:'
Lista de indivíduos para análise:
a=0
+ a=0
for i in $ID; do 
  echo -n "$i  ... " 
  if [ $(find . -name "T1_$i.nii") ] && [ $(find . -name "T1_$i.PAR") ]; then
    echo -n "T1" 
  else echo -n "(T1 não encontrado)"; a=$((a + 1))
  fi
  if [ $(find . -name "RS_$i.nii") ] && [ $(find . -name "RS_$i.PAR") ]; then
    printf " RS" 
  else echo " (RS não encontrado)"; a=$((a + 1)) 
  fi
  [ $(find . -name "z_RS_$i.nii") ] && printf " aztec"
  [ $(find . -name "t*_RS_$i.nii") ] && printf " stc"
  [ $(find . -name "rt*_RS_$i.nii") ] && printf " mc"
  printf "\n"
done
+ for i in '$ID'
+ echo -n 'C000917  ... '
C000917  ... find . -name "T1_$i.nii"
++ find . -name T1_C000917.nii
+ '[' ./DATA/C000917/T1_C000917.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_C000917.PAR
+ '[' ./DATA/C000917/T1_C000917.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_C000917.nii
+ '[' ./DATA/C000917/RS_C000917.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_C000917.PAR
+ '[' ./DATA/C000917/RS_C000917.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_C000917.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_C000917.nii'
+ '[' ./DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_C000917.nii'
+ '[' ./DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'P001543  ... '
P001543  ... find . -name "T1_$i.nii"
++ find . -name T1_P001543.nii
+ '[' ./DATA/P001543/T1_P001543.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001543.PAR
+ '[' ./DATA/P001543/T1_P001543.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001543.nii
+ '[' ./DATA/P001543/RS_P001543.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001543.PAR
+ '[' ./DATA/P001543/RS_P001543.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_P001543.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_P001543.nii'
+ '[' ./DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_P001543.nii'
+ '[' ./DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'P001562  ... '
P001562  ... find . -name "T1_$i.nii"
++ find . -name T1_P001562.nii
+ '[' ./DATA/P001562/T1_P001562.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_P001562.PAR
+ '[' ./DATA/P001562/T1_P001562.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_P001562.nii
+ '[' ./DATA/P001562/RS_P001562.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_P001562.PAR
+ '[' ./DATA/P001562/RS_P001562.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_P001562.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_P001562.nii'
+ '[' ./DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_P001562.nii'
+ '[' ./DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ printf ' mc'
 mc+ printf '\n'

+ for i in '$ID'
+ echo -n 'T000001  ... '
T000001  ... find . -name "T1_$i.nii"
++ find . -name T1_T000001.nii
+ '[' ./DATA/T000001/T1_T000001.nii ']'
find . -name "T1_$i.PAR"
++ find . -name T1_T000001.PAR
+ '[' ./DATA/T000001/T1_T000001.PAR ']'
+ echo -n T1
T1find . -name "RS_$i.nii"
++ find . -name RS_T000001.nii
+ '[' ./DATA/T000001/RS_T000001.nii ']'
find . -name "RS_$i.PAR"
++ find . -name RS_T000001.PAR
+ '[' ./DATA/T000001/RS_T000001.PAR ']'
+ printf ' RS'
 RSfind . -name "z_RS_$i.nii"
++ find . -name z_RS_T000001.nii
+ '[' ']'
find . -name "t*_RS_$i.nii"
++ find . -name 't*_RS_T000001.nii'
+ '[' ./DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ printf ' stc'
 stcfind . -name "rt*_RS_$i.nii"
++ find . -name 'rt*_RS_T000001.nii'
+ '[' ./DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ printf ' mc'
 mc+ printf '\n'

echo
+ echo

if [ ! $a -eq 0 ]; then
    echo "Imagens não foram encontradas ou não estão nomeadas conforme o padrão: RS_<ID>.nii/RS_<ID>.PAR e T1_<ID>.nii/T1_<ID>" | fold -s ; echo
    exit
fi
+ '[' '!' 0 -eq 0 ']'

[ -d DATA ] || mkdir DATA
+ '[' -d DATA ']'
[ -d OUTPUT ] || mkdir OUTPUT
+ '[' -d OUTPUT ']'

unset a; a=0
+ unset a
+ a=0
for i in $ID; do
  [ -d DATA/$i ] || mkdir DATA/$i 
  [ -d OUTPUT/$i ] || mkdir OUTPUT/$i 
  for ii in T1_$i.nii T1_$i.PAR RS_$i.nii RS_$i.PAR physlog_$i; do
    [ ! -f DATA/$i/$ii ] && wp=$(find . -name $ii) && rp=DATA/$i/$ii && mv $wp $rp 2> /dev/null && a=$((a + 1))
  done
done
+ for i in '$ID'
+ '[' -d DATA/C000917 ']'
+ '[' -d OUTPUT/C000917 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/T1_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/RS_C000917.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/C000917/physlog_C000917 ']'
find . -name $ii
++ find . -name physlog_C000917
+ wp=
+ rp=DATA/C000917/physlog_C000917
+ mv DATA/C000917/physlog_C000917
+ for i in '$ID'
+ '[' -d DATA/P001543 ']'
+ '[' -d OUTPUT/P001543 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/T1_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/RS_P001543.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001543/physlog_P001543 ']'
find . -name $ii
++ find . -name physlog_P001543
+ wp=
+ rp=DATA/P001543/physlog_P001543
+ mv DATA/P001543/physlog_P001543
+ for i in '$ID'
+ '[' -d DATA/P001562 ']'
+ '[' -d OUTPUT/P001562 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/T1_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/RS_P001562.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/P001562/physlog_P001562 ']'
find . -name $ii
++ find . -name physlog_P001562
+ wp=
+ rp=DATA/P001562/physlog_P001562
+ mv DATA/P001562/physlog_P001562
+ for i in '$ID'
+ '[' -d DATA/T000001 ']'
+ '[' -d OUTPUT/T000001 ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/T1_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/RS_T000001.PAR ']'
+ for ii in 'T1_$i.nii' 'T1_$i.PAR' 'RS_$i.nii' 'RS_$i.PAR' 'physlog_$i'
+ '[' '!' -f DATA/T000001/physlog_T000001 ']'
find . -name $ii
++ find . -name physlog_T000001
+ wp=
+ rp=DATA/T000001/physlog_T000001
+ mv DATA/T000001/physlog_T000001
if [ ! $a -eq 0 ]; then 
  echo "O caminho das imagens não está conformado com o padrâo: DATA/<ID>/T1_<ID>.nii"
  echo "Conformando..."
  echo
fi
+ '[' '!' 0 -eq 0 ']'

prefix=_RS_
+ prefix=_RS_
declare -A in in_2 in_3 in_4 in_5
+ declare -A in in_2 in_3 in_4 in_5
declare -A inpath
+ declare -A inpath
declare -A out out_2 out_3 ou_4 out_5
+ declare -A out out_2 out_3 ou_4 out_5
declare -A outpath
+ declare -A outpath
for i in $ID; do
out[$i]=RS_$i.nii
outpath[$i]=DATA/$i/
done
+ for i in '$ID'
+ out[$i]=RS_C000917.nii
+ outpath[$i]=DATA/C000917/
+ for i in '$ID'
+ out[$i]=RS_P001543.nii
+ outpath[$i]=DATA/P001543/
+ for i in '$ID'
+ out[$i]=RS_P001562.nii
+ outpath[$i]=DATA/P001562/
+ for i in '$ID'
+ out[$i]=RS_T000001.nii
+ outpath[$i]=DATA/T000001/


# AZTEC========================================================================
if [ $aztec -eq 1 ]; then
  printf "=============================AZTEC==================================\n\n"
  pwd=($PWD)
  prefix=z$prefix
  for i in $ID; do
    #inputs
    in[$i]=${out[$i]}
    in_2[$i]=RS_$i.log
    inpath[$i]=${outpath[$i]}
    #outputs
    out[$i]=$prefix$i.nii
    outpath[$i]=DATA/$i/aztec/
    echo -n "$i> "
    open.node; if [ $go -eq 1 ]; then
      #
   #  if [ ! -d "3d" ]; then  mkdir 3d ; fi && \
   #  fsl5.0-fslsplit ${in[$i]} 3d_"$i"_ -t && \
   #  mv 3d_"$i"* 3d && \
   #  gunzip 3d/3d_$i_* && \
      echo "try aztec(); catch; end" > azt_script.m && \
   #  echo "try aztec('${in[2]}',files ,500,$TR,1,$hp,'/3d') catch  quit" > azt_script.m
      matlab -nosplash -r "run azt_script.m" \
   #  rm 3d/3d* && \
   #  3dTcat -prefix ${out[$i]} -TR $((TR/1000)) 3d/aztec* && \
   #  rm 3d/aztec* 3d azt* && \ 
      &> $prefix$i.log && printf "Processamento da imagem %s realizado com sucesso! \n" "$i" || printf "Houve um erro no processamento da imagem %s, consulte o log %s. " "$i" "$prefix$i.log"
      #
    fi; close.node
    log "Aztec"
  done
  input.error
  echo
fi
+ '[' 0 -eq 1 ']'

# SLICE TIMING CORRECTION=======================================================
printf "=======================SLICE TIMING CORRECTION====================\n\n"
+ printf '=======================SLICE TIMING CORRECTION====================\n\n'
=======================SLICE TIMING CORRECTION====================

pwd=($PWD)
+ pwd=($PWD)
prefix=t$prefix
+ prefix=t_RS_
for i in $ID; do
  #inputs
  in[$i]=${out[$i]}
  inpath[$i]=${outpath[$i]}
  #outputs
  out[$i]=$prefix$i.nii
  outpath[$i]=DATA/$i/slice_correction/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    #
    3dTshift \
      -verbose \
      -tpattern $ptn \
      -prefix ${out[$i]} \
      -Fourier \
      ${in[$i]} &> $prefix$i.log && printf "Processamento da imagem %s realizado com sucesso! \n" "$i" || printf "Houve um erro no processamento da imagem %s, consulte o log %s. " "$i" "$prefix$i.log"
    #
  fi; close.node
  log "Slice Timing Correction"
done
+ for i in '$ID'
+ in[$i]=RS_C000917.nii
+ inpath[$i]=DATA/C000917/
+ out[$i]=t_RS_C000917.nii
+ outpath[$i]=DATA/C000917/slice_correction/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/slice_correction/t_RS_C000917.nii -ot DATA/C000917/RS_C000917.nii ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/C000917/ -name 't_RS_*'
+ local 'files=DATA/C000917/slice_correction/t_RS_C000917.nii
DATA/C000917/slice_correction/t_RS_C000917.log'
+ for f in '$files'
+ mv DATA/C000917/slice_correction/t_RS_C000917.nii DATA/C000917/slice_correction/
+ for f in '$files'
+ mv DATA/C000917/slice_correction/t_RS_C000917.log DATA/C000917/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ in[$i]=RS_P001543.nii
+ inpath[$i]=DATA/P001543/
+ out[$i]=t_RS_P001543.nii
+ outpath[$i]=DATA/P001543/slice_correction/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/slice_correction/t_RS_P001543.nii -ot DATA/P001543/RS_P001543.nii ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/P001543/ -name 't_RS_*'
+ local 'files=DATA/P001543/slice_correction/t_RS_P001543.log
DATA/P001543/slice_correction/t_RS_P001543.nii'
+ for f in '$files'
+ mv DATA/P001543/slice_correction/t_RS_P001543.log DATA/P001543/slice_correction/
+ for f in '$files'
+ mv DATA/P001543/slice_correction/t_RS_P001543.nii DATA/P001543/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ in[$i]=RS_P001562.nii
+ inpath[$i]=DATA/P001562/
+ out[$i]=t_RS_P001562.nii
+ outpath[$i]=DATA/P001562/slice_correction/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/slice_correction/t_RS_P001562.nii -ot DATA/P001562/RS_P001562.nii ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/P001562/ -name 't_RS_*'
+ local 'files=DATA/P001562/slice_correction/t_RS_P001562.nii
DATA/P001562/slice_correction/t_RS_P001562.log'
+ for f in '$files'
+ mv DATA/P001562/slice_correction/t_RS_P001562.nii DATA/P001562/slice_correction/
+ for f in '$files'
+ mv DATA/P001562/slice_correction/t_RS_P001562.log DATA/P001562/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
+ for i in '$ID'
+ in[$i]=RS_T000001.nii
+ inpath[$i]=DATA/T000001/
+ out[$i]=t_RS_T000001.nii
+ outpath[$i]=DATA/T000001/slice_correction/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/slice_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/slice_correction/t_RS_T000001.nii -ot DATA/T000001/RS_T000001.nii ']'
+ '[' 0 -eq 0 ']'
+ '[' 0 -eq 0 ']'
+ '[' '!' 0 -eq 0 ']'
+ echo 'OUTPUT JÁ EXISTE. PROSSEGUINDO.'
OUTPUT JÁ EXISTE. PROSSEGUINDO.
+ go=0
+ ex=0
+ '[' 0 -eq 1 ']'
+ '[' 0 -eq 1 ']'
+ close.node
+ local e=0
+ '[' 0 -eq 1 ']'
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/T000001/ -name 't_RS_*'
+ local 'files=DATA/T000001/slice_correction/t_RS_T000001.log
DATA/T000001/slice_correction/t_RS_T000001.nii'
+ for f in '$files'
+ mv DATA/T000001/slice_correction/t_RS_T000001.log DATA/T000001/slice_correction/
+ for f in '$files'
+ mv DATA/T000001/slice_correction/t_RS_T000001.nii DATA/T000001/slice_correction/
+ log 'Slice Timing Correction'
+ '[' 0 -eq 1 ']'
input.error
+ input.error
+ '[' 0 -eq 1 ']'
echo
+ echo


# MOTION CORRECTION============================================================
printf "\n=========================MOTION CORRECTION=======================\n\n"
+ printf '\n=========================MOTION CORRECTION=======================\n\n'

=========================MOTION CORRECTION=======================

pwd=($PWD)
+ pwd=($PWD)
prefix=r$prefix
+ prefix=rt_RS_
for i in $ID; do
  #inputs
  in[$i]=${out[$i]}
  inpath[$i]=${outpath[$i]}
  #outputs
  out[$i]=$prefix$i.nii
  out_2[$i]="$prefix"mc_$i.1d
  out_3[$i]="$prefix"mcplot_$i.jpg
  outpath[$i]=DATA/$i/motion_correction/
  echo -n "$i> "
  open.node; if [ $go -eq 1 ]; then
    3dvolreg \
    -prefix ${out[$i]} \
    -base 100 \
    -zpad 2 \
    -twopass \
    -Fourier \
    -verbose \
    -1Dfile ${out_2[$i]} \
    ${in[$i]} && \
    1dplot \
    -jpg ${out_3[$i]} \
    -volreg -dx $((TR / 1000)) \
    -xlabel Time \
    -thick \
    ${out_2[$i]} &> $prefix$i.log && printf "Processamento da imagem %s realizado com sucesso! \n" "$i" || printf "Houve um erro no processamento da imagem %s, consulte o log %s. " "$i" "$prefix$i.log"
  fi; close.node
  log "Motion Correction "
done
+ for i in '$ID'
+ in[$i]=t_RS_C000917.nii
+ inpath[$i]=DATA/C000917/slice_correction/
+ out[$i]=rt_RS_C000917.nii
+ out_2[$i]=rt_RS_mc_C000917.1d
+ out_3[$i]=rt_RS_mcplot_C000917.jpg
+ outpath[$i]=DATA/C000917/motion_correction/
+ echo -n 'C000917> '
C000917> + open.node
+ '[' -d DATA/C000917/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ d=1
+ '[' DATA/C000917/motion_correction/rt_RS_C000917.nii -ot DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_mc_C000917.1d ']'
+ d=2
+ '[' DATA/C000917/motion_correction/rt_RS_mc_C000917.1d -ot DATA/C000917/slice_correction/t_RS_C000917.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/C000917/motion_correction/rt_RS_mcplot_C000917.jpg ']'
+ b=1
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 2 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. REFAZENDO ANÁLISE.'
OUTPUT CORROMPIDO. REFAZENDO ANÁLISE.
+ for ii in '${out[@]}'
+ rm DATA/C000917/motion_correction/t_RS_P001543.nii
+ for ii in '${out[@]}'
+ rm DATA/C000917/motion_correction/t_RS_T000001.nii
+ for ii in '${out[@]}'
+ rm DATA/C000917/motion_correction/rt_RS_C000917.nii
+ for ii in '${out[@]}'
+ rm DATA/C000917/motion_correction/t_RS_P001562.nii
+ '[' 1 -eq 1 ']'
+ cd DATA/C000917/slice_correction/
+ '[' 1 -eq 1 ']'
+ 3dvolreg -prefix rt_RS_C000917.nii -base 100 -zpad 2 -twopass -Fourier -verbose -1Dfile rt_RS_mc_C000917.1d t_RS_C000917.nii
++ 3dvolreg: AFNI version=AFNI_2011_12_21_1014 (Mar  6 2016) [64-bit]
++ Authored by: RW Cox
*+ WARNING:   If you are performing spatial transformations on an oblique dset, 
  such as t_RS_C000917.nii,
  or viewing/combining it with volumes of differing obliquity,
  you should consider running: 
     3dWarp -deoblique 
  on this and  other oblique datasets in the same session.
 See 3dWarp -help for details.
++ Oblique dataset:t_RS_C000917.nii is 5.648023 degrees from plumb.
++ Coarse del was 10, replaced with 3
++ Reading input dataset t_RS_C000917.nii

Fatal Signal 2 (SIGINT) received
Last STATUS: calling nifti_image_read_bricks
    THD_load_nifti
   THD_load_datablock
  3dvolreg main
 Bottom of Debug Stack
** AFNI version = AFNI_2011_12_21_1014  Compile date = Mar  6 2016
** [[Precompiled binary =Debian-x86_64-1-gnu: Mar  6 2016]]
** Program Abort **
+ printf 'Houve um erro no processamento da imagem %s, consulte o log %s. ' C000917 rt_RS_C000917.log
Houve um erro no processamento da imagem C000917, consulte o log rt_RS_C000917.log. + close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv 'DATA/C000917/slice_correction/rt_RS_*' DATA/C000917/motion_correction/
mv: cannot stat ‘DATA/C000917/slice_correction/rt_RS_*’: No such file or directory
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/C000917/motion_correction/rt_RS_C000917.nii ']'
+ e=1
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/C000917/motion_correction/rt_RS_mc_C000917.1d ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/C000917/motion_correction/rt_RS_mcplot_C000917.jpg ']'
+ e=2
+ '[' '!' 2 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. CONSULTE O LOG.'
OUTPUT CORROMPIDO. CONSULTE O LOG.
+ ex=1
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/C000917/slice_correction/ -name 'rt_RS_*'
+ local files=
+ log 'Motion Correction '
+ '[' 1 -eq 1 ']'
+ echo
date
++ date
+ echo 'ETAPA: Motion Correction   - RUNTIME: Thu Dec  8 18:26:09 BRST 2016'
+ echo
+ echo 'PREFIX: rt_RS_'
+ echo 'INPUT PATH: DATA/C000917/slice_correction/ '
+ echo 'INPUTS: t_RS_C000917.nii   '
+ echo 'OUTPUT PATH: DATA/C000917/motion_correction/'
+ echo 'OUTPUTS: rt_RS_C000917.nii rt_RS_mc_C000917.1d rt_RS_mcplot_C000917.jpg '
+ echo
+ cat DATA/C000917/motion_correction/rt_RS_C000917.log
+ for i in '$ID'
+ in[$i]=t_RS_P001543.nii
+ inpath[$i]=DATA/P001543/slice_correction/
+ out[$i]=rt_RS_P001543.nii
+ out_2[$i]=rt_RS_mc_P001543.1d
+ out_3[$i]=rt_RS_mcplot_P001543.jpg
+ outpath[$i]=DATA/P001543/motion_correction/
+ echo -n 'P001543> '
P001543> + open.node
+ '[' -d DATA/P001543/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ d=1
+ '[' DATA/P001543/motion_correction/rt_RS_P001543.nii -ot DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_mc_P001543.1d ']'
+ d=2
+ '[' DATA/P001543/motion_correction/rt_RS_mc_P001543.1d -ot DATA/P001543/slice_correction/t_RS_P001543.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001543/motion_correction/rt_RS_mcplot_P001543.jpg ']'
+ b=1
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 2 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. REFAZENDO ANÁLISE.'
OUTPUT CORROMPIDO. REFAZENDO ANÁLISE.
+ for ii in '${out[@]}'
+ rm DATA/P001543/motion_correction/rt_RS_P001543.nii
+ for ii in '${out[@]}'
+ rm DATA/P001543/motion_correction/t_RS_T000001.nii
+ for ii in '${out[@]}'
+ rm DATA/P001543/motion_correction/rt_RS_C000917.nii
+ for ii in '${out[@]}'
+ rm DATA/P001543/motion_correction/t_RS_P001562.nii
+ '[' 1 -eq 1 ']'
+ cd DATA/P001543/slice_correction/
+ '[' 1 -eq 1 ']'
+ 3dvolreg -prefix rt_RS_P001543.nii -base 100 -zpad 2 -twopass -Fourier -verbose -1Dfile rt_RS_mc_P001543.1d t_RS_P001543.nii
++ 3dvolreg: AFNI version=AFNI_2011_12_21_1014 (Mar  6 2016) [64-bit]
++ Authored by: RW Cox
*+ WARNING:   If you are performing spatial transformations on an oblique dset, 
  such as t_RS_P001543.nii,
  or viewing/combining it with volumes of differing obliquity,
  you should consider running: 
     3dWarp -deoblique 
  on this and  other oblique datasets in the same session.
 See 3dWarp -help for details.
++ Oblique dataset:t_RS_P001543.nii is 15.935398 degrees from plumb.
++ Coarse del was 10, replaced with 4
++ Reading input dataset t_RS_P001543.nii

Fatal Signal 2 (SIGINT) received
  3dvolreg main
 Bottom of Debug Stack
** AFNI version = AFNI_2011_12_21_1014  Compile date = Mar  6 2016
** [[Precompiled binary =Debian-x86_64-1-gnu: Mar  6 2016]]
** Program Abort **

Fatal Signal 2 (SIGINT) received
Last STATUS: calling nifti_image_read_bricks
    THD_load_nifti
   THD_load_datablock
  3dvolreg main
 Bottom of Debug Stack
** AFNI version = AFNI_2011_12_21_1014  Compile date = Mar  6 2016
** [[Precompiled binary =Debian-x86_64-1-gnu: Mar  6 2016]]
** Program Abort **
+ printf 'Houve um erro no processamento da imagem %s, consulte o log %s. ' P001543 rt_RS_P001543.log
Houve um erro no processamento da imagem P001543, consulte o log rt_RS_P001543.log. + close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv 'DATA/P001543/slice_correction/rt_RS_*' DATA/P001543/motion_correction/
mv: cannot stat ‘DATA/P001543/slice_correction/rt_RS_*’: No such file or directory
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001543/motion_correction/rt_RS_P001543.nii ']'
+ e=1
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001543/motion_correction/rt_RS_mc_P001543.1d ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001543/motion_correction/rt_RS_mcplot_P001543.jpg ']'
+ e=2
+ '[' '!' 2 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. CONSULTE O LOG.'
OUTPUT CORROMPIDO. CONSULTE O LOG.
+ ex=1
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/P001543/slice_correction/ -name 'rt_RS_*'
+ local files=
+ log 'Motion Correction '
+ '[' 1 -eq 1 ']'
+ echo
date
++ date
+ echo 'ETAPA: Motion Correction   - RUNTIME: Thu Dec  8 18:26:09 BRST 2016'
+ echo
+ echo 'PREFIX: rt_RS_'
+ echo 'INPUT PATH: DATA/P001543/slice_correction/ '
+ echo 'INPUTS: t_RS_P001543.nii   '
+ echo 'OUTPUT PATH: DATA/P001543/motion_correction/'
+ echo 'OUTPUTS: rt_RS_P001543.nii rt_RS_mc_P001543.1d rt_RS_mcplot_P001543.jpg '
+ echo
+ cat DATA/P001543/motion_correction/rt_RS_P001543.log
+ for i in '$ID'
+ in[$i]=t_RS_P001562.nii
+ inpath[$i]=DATA/P001562/slice_correction/
+ out[$i]=rt_RS_P001562.nii
+ out_2[$i]=rt_RS_mc_P001562.1d
+ out_3[$i]=rt_RS_mcplot_P001562.jpg
+ outpath[$i]=DATA/P001562/motion_correction/
+ echo -n 'P001562> '
P001562> + open.node
+ '[' -d DATA/P001562/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ d=1
+ '[' DATA/P001562/motion_correction/rt_RS_P001562.nii -ot DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_mc_P001562.1d ']'
+ d=2
+ '[' DATA/P001562/motion_correction/rt_RS_mc_P001562.1d -ot DATA/P001562/slice_correction/t_RS_P001562.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/P001562/motion_correction/rt_RS_mcplot_P001562.jpg ']'
+ b=1
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 2 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. REFAZENDO ANÁLISE.'
OUTPUT CORROMPIDO. REFAZENDO ANÁLISE.
+ for ii in '${out[@]}'
+ rm DATA/P001562/motion_correction/rt_RS_P001543.nii
+ for ii in '${out[@]}'
+ rm DATA/P001562/motion_correction/t_RS_T000001.nii
+ for ii in '${out[@]}'
+ rm DATA/P001562/motion_correction/rt_RS_C000917.nii
+ for ii in '${out[@]}'
+ rm DATA/P001562/motion_correction/rt_RS_P001562.nii
+ '[' 1 -eq 1 ']'
+ cd DATA/P001562/slice_correction/
+ '[' 1 -eq 1 ']'
+ 3dvolreg -prefix rt_RS_P001562.nii -base 100 -zpad 2 -twopass -Fourier -verbose -1Dfile rt_RS_mc_P001562.1d t_RS_P001562.nii
++ 3dvolreg: AFNI version=AFNI_2011_12_21_1014 (Mar  6 2016) [64-bit]
++ Authored by: RW Cox
*+ WARNING:   If you are performing spatial transformations on an oblique dset, 
  such as t_RS_P001562.nii,
  or viewing/combining it with volumes of differing obliquity,
  you should consider running: 
     3dWarp -deoblique 
  on this and  other oblique datasets in the same session.
 See 3dWarp -help for details.
++ Oblique dataset:t_RS_P001562.nii is 10.300989 degrees from plumb.
++ Coarse del was 10, replaced with 4
++ Reading input dataset t_RS_P001562.nii

Fatal Signal 2 (SIGINT) received
  3dvolreg main
 Bottom of Debug Stack
** AFNI version = AFNI_2011_12_21_1014  Compile date = Mar  6 2016
** [[Precompiled binary =Debian-x86_64-1-gnu: Mar  6 2016]]
** Program Abort **

Fatal Signal 2 (SIGINT) received
Last STATUS: calling nifti_image_read_bricks
    THD_load_nifti
   THD_load_datablock
  3dvolreg main
 Bottom of Debug Stack
** AFNI version = AFNI_2011_12_21_1014  Compile date = Mar  6 2016
** [[Precompiled binary =Debian-x86_64-1-gnu: Mar  6 2016]]
** Program Abort **
+ printf 'Houve um erro no processamento da imagem %s, consulte o log %s. ' P001562 rt_RS_P001562.log
Houve um erro no processamento da imagem P001562, consulte o log rt_RS_P001562.log. + close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv 'DATA/P001562/slice_correction/rt_RS_*' DATA/P001562/motion_correction/
mv: cannot stat ‘DATA/P001562/slice_correction/rt_RS_*’: No such file or directory
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001562/motion_correction/rt_RS_P001562.nii ']'
+ e=1
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001562/motion_correction/rt_RS_mc_P001562.1d ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/P001562/motion_correction/rt_RS_mcplot_P001562.jpg ']'
+ e=2
+ '[' '!' 2 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. CONSULTE O LOG.'
OUTPUT CORROMPIDO. CONSULTE O LOG.
+ ex=1
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/P001562/slice_correction/ -name 'rt_RS_*'
+ local files=
+ log 'Motion Correction '
+ '[' 1 -eq 1 ']'
+ echo
date
++ date
+ echo 'ETAPA: Motion Correction   - RUNTIME: Thu Dec  8 18:26:10 BRST 2016'
+ echo
+ echo 'PREFIX: rt_RS_'
+ echo 'INPUT PATH: DATA/P001562/slice_correction/ '
+ echo 'INPUTS: t_RS_P001562.nii   '
+ echo 'OUTPUT PATH: DATA/P001562/motion_correction/'
+ echo 'OUTPUTS: rt_RS_P001562.nii rt_RS_mc_P001562.1d rt_RS_mcplot_P001562.jpg '
+ echo
+ cat DATA/P001562/motion_correction/rt_RS_P001562.log
+ for i in '$ID'
+ in[$i]=t_RS_T000001.nii
+ inpath[$i]=DATA/T000001/slice_correction/
+ out[$i]=rt_RS_T000001.nii
+ out_2[$i]=rt_RS_mc_T000001.1d
+ out_3[$i]=rt_RS_mcplot_T000001.jpg
+ outpath[$i]=DATA/T000001/motion_correction/
+ echo -n 'T000001> '
T000001> + open.node
+ '[' -d DATA/T000001/motion_correction/ ']'
+ local a=0
+ local b=0
+ local c=0
+ local d=0
+ local v=0
+ ex=0
+ go=1
+ for ii in '${in[$i]}' '${in_2[$i]}' '${in_3[$i]}' '${in_4[$i]}'
+ '[' '!' -f DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ d=1
+ '[' DATA/T000001/motion_correction/rt_RS_T000001.nii -ot DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_mc_T000001.1d ']'
+ d=2
+ '[' DATA/T000001/motion_correction/rt_RS_mc_T000001.1d -ot DATA/T000001/slice_correction/t_RS_T000001.nii ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' '!' -f DATA/T000001/motion_correction/rt_RS_mcplot_T000001.jpg ']'
+ b=1
+ '[' 0 -eq 0 ']'
+ '[' 1 -eq 0 ']'
+ '[' '!' 2 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. REFAZENDO ANÁLISE.'
OUTPUT CORROMPIDO. REFAZENDO ANÁLISE.
+ for ii in '${out[@]}'
+ rm DATA/T000001/motion_correction/rt_RS_P001543.nii
+ for ii in '${out[@]}'
+ rm DATA/T000001/motion_correction/rt_RS_T000001.nii
+ for ii in '${out[@]}'
+ rm DATA/T000001/motion_correction/rt_RS_C000917.nii
+ for ii in '${out[@]}'
+ rm DATA/T000001/motion_correction/rt_RS_P001562.nii
+ '[' 1 -eq 1 ']'
+ cd DATA/T000001/slice_correction/
+ '[' 1 -eq 1 ']'
+ 3dvolreg -prefix rt_RS_T000001.nii -base 100 -zpad 2 -twopass -Fourier -verbose -1Dfile rt_RS_mc_T000001.1d t_RS_T000001.nii
++ 3dvolreg: AFNI version=AFNI_2011_12_21_1014 (Mar  6 2016) [64-bit]
++ Authored by: RW Cox
*+ WARNING:   If you are performing spatial transformations on an oblique dset, 
  such as t_RS_T000001.nii,
  or viewing/combining it with volumes of differing obliquity,
  you should consider running: 
     3dWarp -deoblique 
  on this and  other oblique datasets in the same session.
 See 3dWarp -help for details.
++ Oblique dataset:t_RS_T000001.nii is 8.347956 degrees from plumb.
++ Coarse del was 10, replaced with 4
++ Reading input dataset t_RS_T000001.nii

Fatal Signal 2 (SIGINT) received
  3dvolreg main
 Bottom of Debug Stack
** AFNI version = AFNI_2011_12_21_1014  Compile date = Mar  6 2016
** [[Precompiled binary =Debian-x86_64-1-gnu: Mar  6 2016]]
** Program Abort **

Fatal Signal 2 (SIGINT) received
Last STATUS: calling nifti_image_read_bricks
    THD_load_nifti
   THD_load_datablock
  3dvolreg main
 Bottom of Debug Stack
** AFNI version = AFNI_2011_12_21_1014  Compile date = Mar  6 2016
** [[Precompiled binary =Debian-x86_64-1-gnu: Mar  6 2016]]
** Program Abort **
+ printf 'Houve um erro no processamento da imagem %s, consulte o log %s. ' T000001 rt_RS_T000001.log
Houve um erro no processamento da imagem T000001, consulte o log rt_RS_T000001.log. + close.node
+ local e=0
+ '[' 1 -eq 1 ']'
+ cd /home/brain/Desktop/PROJETO_CIRCOS/PREPROCESSING
+ mv 'DATA/T000001/slice_correction/rt_RS_*' DATA/T000001/motion_correction/
mv: cannot stat ‘DATA/T000001/slice_correction/rt_RS_*’: No such file or directory
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/T000001/motion_correction/rt_RS_T000001.nii ']'
+ e=1
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/T000001/motion_correction/rt_RS_mc_T000001.1d ']'
+ for iii in '${out[$i]}' '${out_2[$i]}' '${out_3[$i]}' '${out_4[$i]}'
+ '[' -f DATA/T000001/motion_correction/rt_RS_mcplot_T000001.jpg ']'
+ e=2
+ '[' '!' 2 -eq 0 ']'
+ echo 'OUTPUT CORROMPIDO. CONSULTE O LOG.'
OUTPUT CORROMPIDO. CONSULTE O LOG.
+ ex=1
 find "${inpath[$i]}" -name "$prefix*" 
++ find DATA/T000001/slice_correction/ -name 'rt_RS_*'
+ local files=
+ log 'Motion Correction '
+ '[' 1 -eq 1 ']'
+ echo
date
++ date
+ echo 'ETAPA: Motion Correction   - RUNTIME: Thu Dec  8 18:26:10 BRST 2016'
+ echo
+ echo 'PREFIX: rt_RS_'
+ echo 'INPUT PATH: DATA/T000001/slice_correction/ '
+ echo 'INPUTS: t_RS_T000001.nii   '
+ echo 'OUTPUT PATH: DATA/T000001/motion_correction/'
+ echo 'OUTPUTS: rt_RS_T000001.nii rt_RS_mc_T000001.1d rt_RS_mcplot_T000001.jpg '
+ echo
+ cat DATA/T000001/motion_correction/rt_RS_T000001.log
input.error
+ input.error
+ '[' 1 -eq 1 ']'
+ exit
