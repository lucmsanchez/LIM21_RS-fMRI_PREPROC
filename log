#!/usr/bin/env bash

# PROCESSANDO OS ARGUMENTOS ====================================================
usage() {
    echo "Argumentos:"
    echo " $0 [ --var <txt com variáveis para análise> | --subs <ID das imagens> ]"
    echo " $0 [ -h | --help ]"
    echo
}



i=$(($# + 1)) # index of the first non-existing argument
+ i=5
declare -A longoptspec
+ declare -A longoptspec
longoptspec=( [config]=1 [subs]=1 )
+ longoptspec=([config]=1 [subs]=1)
optspec=":l:h-:"
+ optspec=:l:h-:
while getopts "$optspec" opt; do
while true; do
    case "${opt}" in
        -) #OPTARG is name-of-long-option or name-of-long-option=value
            if [[ ${OPTARG} =~ .*=.* ]] # with this --key=value format only one argument is possible
            then
                opt=${OPTARG/=*/}
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                if (($((longoptspec[$opt])) != 1))
                then
                    echo "Syntax error: Option '$opt' does not support this syntax." >&2
                    exit
                fi
                OPTARG=${OPTARG#*=}
            else #with this --key value1 value2 format multiple arguments are possible
                opt="$OPTARG"
                ((${#opt} <= 1)) && {
                    echo "Syntax error: Invalid long option '$opt'" >&2
                    exit
                }
                OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
                ((OPTIND+=longoptspec[$opt]))
                #echo $OPTIND
                ((OPTIND > i)) && {
                    echo "Syntax error: Not all required arguments for option '$opt' are given." >&2
                    exit
                }
            fi

            continue #now that opt/OPTARG are set we can process them as
            # if getopts would've given us long options
            ;;
        c|config)
          config=$OPTARG
            ;;
        s|subs)
            subs=$OPTARG
            ;;
        h|help)
            usage
            exit 0
            ;;
        ?)
            echo "Erro de sintaxe:'$OPTARG' desconhecida" >&2
            usage
            exit
            ;;
        *)
            echo "Erro de sintaxe:'$opt' desconhecida'" >&2
            usage
            exit
            ;;
    esac
break; done
done
+ getopts :l:h-: opt
+ true
+ case "${opt}" in
+ [[ config =~ .*=.* ]]
+ opt=config
+ (( 6 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[config] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ config=preproc.cfg
+ break
+ getopts :l:h-: opt
+ true
+ case "${opt}" in
+ [[ subs =~ .*=.* ]]
+ opt=subs
+ (( 4 <= 1 ))
+ OPTARG=(${@:OPTIND:$((longoptspec[$opt]))})
+ (( OPTIND+=longoptspec[subs] ))
+ (( OPTIND > i ))
+ continue
+ true
+ case "${opt}" in
+ subs=preproc.sbj
+ break
+ getopts :l:h-: opt

# ==============================================================================

# DECLARANDO FUNÇÕES ===========================================================
check () {
  if command -v $1 > /dev/null; then
    echo "OK"
  else
    echo "Não encontrado em \$PATH"
fi
}

node () {
    [ -d $outpath ] || mkdir $outpath

    local a=0; local b=0; local c=0; local d=0; local e=0

    for i in ${in[@]}; do
        if [ ! -f $inpath$i ]; then
            echo "INPUT $i não encontrado"
            a=$((a + 1))            
        else
            for ii in ${out[@]}; do
                if [ -f $outpath$ii ]; then
                    b=$((b + 1))
                    [ $outpath$ii -ot $inpath$i ] && echo "INPUT $i MODIFICADO." && c=$((c + 1))
                fi
            done
        fi
    done

    echo $a $b $c

    [ $a -eq 0 ] || exit

    if [ $b -eq ${#out[@]} ]; then 
        echo "OUTPUT JÁ EXISTE. PROSSEGUINDO."; d=1
    else
        if [ ! $b -eq 0 ]; then
            echo "OUTPUT CORROMPIDO. REFAZENDO ANÁLISE."
            for ii in ${out[@]}; do rm $outpath$ii; done
    fi

    [ $c -eq 0 ] || for ii in ${out[@]}; do rm $outpath$ii; done

    while d=0; do
    cd $inpath
      $1 &> $prefix$i.log \
        && printf "Processamento da imagem %s realizado com sucesso!\n" "$i" \
        || printf "Houve um erro no processamento da imagem %s, consulte o log %s\n" "$i" "$prefix$i.log" | fold -s
      cd $pwd
      mv $inpath$prefix* $outpath
    done

    for ii in ${out[@]}; do [ -f $outpath$ii ] ||  e=$((e + 1)) done
      
    [ ! $e -eq 0 ] && echo "OUTPUT CORROMPIDO. CONSULTE O LOG." && exit
}
./preproc.sh: line 132: syntax error near unexpected token `}'
./preproc.sh: line 132: `}'
